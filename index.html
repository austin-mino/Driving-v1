<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>3D driving</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #121212;
      font-family: 'Segoe UI', Tahoma, Verdana, sans-serif;
      color: #fff;
      user-select: none;
    }
    #rotateWarning {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.85);
      padding: 25px 40px;
      border-radius: 15px;
      font-size: 1.3rem;
      font-weight: bold;
      z-index: 1000;
      display: none;
    }
    #hud, #gearDisplay, #timerDisplay {
      position: fixed;
      background: rgba(0, 0, 0, 0.7);
      padding: 12px 18px;
      border-radius: 10px;
      font-weight: 700;
      font-size: 18px;
      user-select: none;
      z-index: 100;
    }
    #hud { top: 20px; left: 20px; }
    #gearDisplay { top: 10px; right: 20px; }
    #timerDisplay { top: 60px; left: 20px; }
    #gearControls {
      position: fixed;
      top: 50px;
      right: 20px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      z-index: 100;
    }
    #controlsLeft, #driveControls {
      position: fixed;
      bottom: 20px;
      display: flex;
      gap: 15px;
      z-index: 100;
      user-select: none;
    }
    #controlsLeft { left: 20px; }
    #driveControls { right: 20px; }
    button.controlBtn {
      padding: 14px 20px;
      border-radius: 12px;
      border: none;
      background: #0078d7;
      color: #fff;
      font-weight: 700;
      font-size: 16px;
      cursor: pointer;
      touch-action: manipulation;
      transition: background-color 0.2s, color 0.2s;
    }
    button.controlBtn:active {
      background: #005a9e;
    }
    @media (max-width: 600px) {
      button.controlBtn {
        padding: 18px 22px;
        font-size: 20px;
      }
    }

    #cameraToggleBtn {
      position: fixed;
      top: 140px;
      right: 20px;
      padding: 8px 12px;
      background: rgba(0, 120, 215, 0.7);
      border-radius: 10px;
      font-weight: 700;
      font-size: 14px;
      cursor: pointer;
      z-index: 150;
      user-select: none;
      transition: background-color 0.3s;
    }
    #cameraToggleBtn:hover {
      background: rgba(0, 120, 215, 1);
    }
  </style>
</head>
<body>
  <div id="rotateWarning">가로 모드로 전환해주세요</div>
  <div id="hud">속도: 0 km/h</div>
  <div id="timerDisplay">타이머: 0.00 s</div>
  <div id="gearDisplay">기어: P</div>

  <!-- 좌/우 스티어링 -->
  <div id="controlsLeft">
    <button id="btnLeft" class="controlBtn">◀ 좌</button>
    <button id="btnRight" class="controlBtn">우 ▶</button>
  </div>
  <!-- 엑셀·브레이크 -->
  <div id="driveControls">
    <button id="btnAccel" class="controlBtn">엑셀</button>
    <button id="btnBrake" class="controlBtn">브레이크</button>
  <div id="reset">
    <!-- 기어 선택 아래에 추가 -->
    <button id="btnReset" class="controlBtn">차량 리셋</button>
  </div>
  </div>
  <!-- 기어 선택 -->
  <div id="gearControls">
    <button id="gearP" class="controlBtn">P</button>
    <button id="gearR" class="controlBtn">R</button>
    <button id="gearN" class="controlBtn">N</button>
    <button id="gearD" class="controlBtn">D</button>
  </div>

  <div id="cameraToggleBtn">카메라 모드: 뒤쪽</div>

  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js';
    import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js';

    // 렌더러 설정
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // 마우스 드래그로 자유 카메라 조작 변수
    let isDragging = false;
    let previousMousePosition = { x: 0, y: 0 };
    let yaw = 0;
    let pitch = 0.15;
    const sensitivity = 0.005;

    renderer.domElement.addEventListener('mousedown', (event) => {
      if (event.button === 0) {
        isDragging = true;
        previousMousePosition.x = event.clientX;
        previousMousePosition.y = event.clientY;
      }
    });
    renderer.domElement.addEventListener('mouseup', (event) => {
      if (event.button === 0) {
        isDragging = false;
      }
    });
    renderer.domElement.addEventListener('mousemove', (event) => {
      if (!isDragging) return;

      const deltaMove = {
        x: event.clientX - previousMousePosition.x,
        y: event.clientY - previousMousePosition.y
      };

      yaw -= deltaMove.x * sensitivity;
      pitch -= deltaMove.y * sensitivity;

      const pitchLimit = Math.PI / 3;
      pitch = Math.max(-pitchLimit, Math.min(pitchLimit, pitch));

      previousMousePosition.x = event.clientX;
      previousMousePosition.y = event.clientY;
    });

    // 가로모드 체크
    const rotateWarning = document.getElementById('rotateWarning');
    function checkOrientation() {
      rotateWarning.style.display = window.innerHeight > window.innerWidth ? 'block' : 'none';
    }
    window.addEventListener('resize', checkOrientation);
    window.addEventListener('orientationchange', checkOrientation);
    checkOrientation();

    // 씬, 카메라 설정
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x222222);
    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.05, 5000);
    camera.position.set(0, 5, 15);
    camera.lookAt(0, 0, 0);

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // 차량 리셋 함수
    const btnReset = document.getElementById('btnReset');
    btnReset.addEventListener('click', resetCar);
    window.addEventListener('keydown', e => {
      if (e.key.toLowerCase() === 'r') resetCar();
    });
    function resetCar() {
      const pos = chassisBody.position;
      chassisBody.position.set(pos.x, pos.y + 1.5, pos.z);

      const yRot = getYRotation(chassisBody.quaternion);
      chassisBody.quaternion.setFromEuler(0, yRot, 0);

      chassisBody.velocity.set(0, 0, 0);
      chassisBody.angularVelocity.set(0, 0, 0);
    }
    function getYRotation(q) {
      const siny_cosp = 2 * (q.w * q.y + q.z * q.x);
      const cosy_cosp = 1 - 2 * (q.y * q.y + q.z * q.z);
      return Math.atan2(siny_cosp, cosy_cosp);
    }

    // 물리 월드 생성
    const world = new CANNON.World({ gravity: new CANNON.Vec3(0, -9.82, 0) });
    world.broadphase = new CANNON.SAPBroadphase(world);
    world.defaultContactMaterial.friction = 0.6;

    // 지면 생성
    const groundBody = new CANNON.Body({ mass: 0 });
    groundBody.addShape(new CANNON.Plane());
    groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
    world.addBody(groundBody);

    // 트랙 타원 파라미터
    const trackA = 500;  
    const trackB = 60;   
    const trackWidth = 60;
    const numSegments = 400; 

    // 바리어 생성
    const barrierHeight = 1;
    const barrierThickness = 1;
    const barrierLength = 25;

    const barrierMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
    const barrierMeshes = [];

    for (let i = 0; i < numSegments; i++) {
      const angle = (i / numSegments) * 2 * Math.PI;

      const cx = Math.cos(angle);
      const sz = Math.sin(angle);

      const innerX = (trackA - trackWidth / 2) * cx;
      const innerZ = (trackB - trackWidth / 2) * sz;

      const outerX = (trackA + trackWidth / 2) * cx;
      const outerZ = (trackB + trackWidth / 2) * sz;

      const rotationY = -Math.atan2(
        (trackB * Math.cos(angle)),
        (-trackA * Math.sin(angle))
      );

      [[innerX, innerZ], [outerX, outerZ]].forEach(([x, z]) => {
        const barrierShape = new CANNON.Box(new CANNON.Vec3(barrierLength / 2, barrierHeight / 2, barrierThickness / 2));
        const barrierBody = new CANNON.Body({ mass: 0, shape: barrierShape });
        barrierBody.position.set(x, barrierHeight / 2, z);
        barrierBody.quaternion.setFromEuler(0, rotationY, 0);
        world.addBody(barrierBody);

        const barrierMesh = new THREE.Mesh(new THREE.BoxGeometry(barrierLength, barrierHeight, barrierThickness), barrierMat);
        barrierMesh.position.copy(barrierBody.position);
        barrierMesh.quaternion.copy(barrierBody.quaternion);
        scene.add(barrierMesh);
        barrierMeshes.push(barrierMesh);
      });
    }

    // 평면 (땅) 생성 (검정색)
    const groundMesh = new THREE.Mesh(
      new THREE.PlaneGeometry(3000, 3000),
      new THREE.MeshStandardMaterial({ color: 0x0a0a0a, roughness: 0.9, metalness: 0 })
    );
    groundMesh.rotation.x = -Math.PI / 2;
    scene.add(groundMesh);

    // 조명
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.45);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
    directionalLight.position.set(-5, 15, 10);
    directionalLight.castShadow = true;
    directionalLight.shadow.mapSize.width = 2048;
    directionalLight.shadow.mapSize.height = 2048;
    directionalLight.shadow.camera.near = 0.5;
    directionalLight.shadow.camera.far = 50;
    directionalLight.shadow.camera.left = -15;
    directionalLight.shadow.camera.right = 15;
    directionalLight.shadow.camera.top = 15;
    directionalLight.shadow.camera.bottom = -15;
    scene.add(directionalLight);

    // 카메라 모드 변수 및 토글 버튼
    const cameraToggleBtn = document.getElementById('cameraToggleBtn');
    let cameraFollow = true;
    cameraToggleBtn.addEventListener('click', () => {
      cameraFollow = !cameraFollow;
      cameraToggleBtn.textContent = `카메라 모드: ${cameraFollow ? '뒤쪽' : '자유'}`;
    });

    // 차체 물리 및 메시 생성 함수
    const chassisShape = new CANNON.Box(new CANNON.Vec3(2.7, 0.7, 1.05)); // 절반 길이/높이/폭
    const chassisBody = new CANNON.Body({ mass: 1500 });
    chassisBody.addShape(chassisShape);
    chassisBody.position.set(0, 5, 0);
    chassisBody.angularDamping = 0.5;
    world.addBody(chassisBody);

    // 차체 메시 (차체 모델 함수)
    function createGrandeurIGCarDetailed() {
      const car = new THREE.Group();

      const bodyMat = new THREE.MeshStandardMaterial({ color: 0x0b3b7c, metalness: 0.4, roughness: 0.3 });

      const mainBodyGeom = new THREE.BoxGeometry(5.4, 1.4, 2.1);
      const mainBodyMesh = new THREE.Mesh(mainBodyGeom, bodyMat);
      mainBodyMesh.position.set(0, 0.7, 0);
      car.add(mainBodyMesh);

      const bonnetGeom = new THREE.BoxGeometry(1.2, 0.5, 2.1);
      const bonnetMesh = new THREE.Mesh(bonnetGeom, bodyMat);
      bonnetMesh.position.set(3.3, 1.2, 0);
      car.add(bonnetMesh);

      const trunkGeom = new THREE.BoxGeometry(1.4, 0.5, 2.1);
      const trunkMesh = new THREE.Mesh(trunkGeom, bodyMat);
      trunkMesh.position.set(-3.2, 1.2, 0);
      car.add(trunkMesh);

      const windowMat = new THREE.MeshStandardMaterial({ color: 0x6ea1c7, metalness: 0.1, roughness: 0.1, transparent: true, opacity: 0.7 });
      const windowGeom = new THREE.BoxGeometry(4.2, 0.8, 1.8);
      const windowMesh = new THREE.Mesh(windowGeom, windowMat);
      windowMesh.position.set(0, 1.6, 0);
      car.add(windowMesh);

      return car;
    }

    const carModel = createGrandeurIGCarDetailed();
    scene.add(carModel);

    // 휠 옵션
    const wheelOptions = {
      radius: 0.5,
      directionLocal: new CANNON.Vec3(0, -1, 0),
      suspensionStiffness: 40,
      suspensionRestLength: 0.3,
      frictionSlip: 3,
      dampingRelaxation: 2.3,
      dampingCompression: 4.4,
      maxSuspensionForce: 100000,
      rollInfluence: 0.01,
      axleLocal: new CANNON.Vec3(-1, 0, 0),
      chassisConnectionPointLocal: new CANNON.Vec3(),
      maxSuspensionTravel: 0.3,
      customSlidingRotationalSpeed: -30,
      useCustomSlidingRotationalSpeed: true,
    };

    // 휠 메시 생성 함수
    function createWheel() {
      const wheelGroup = new THREE.Group();

      const tireMat = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.5, roughness: 0.7 });
      const tireGeom = new THREE.CylinderGeometry(0.5, 0.5, 0.3, 32);
      const tireMesh = new THREE.Mesh(tireGeom, tireMat);
      tireMesh.rotation.z = Math.PI / 2;
      wheelGroup.add(tireMesh);

      const rimMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, metalness: 1, roughness: 0.25 });
      const rimGeom = new THREE.CylinderGeometry(0.35, 0.35, 0.15, 16);
      const rimMesh = new THREE.Mesh(rimGeom, rimMat);
      rimMesh.rotation.z = Math.PI / 2;
      wheelGroup.add(rimMesh);

      return wheelGroup;
    }

    // 차량 물리 레이캐스트 차량 생성
    const vehicle = new CANNON.RaycastVehicle({
      chassisBody: chassisBody,
      indexRightAxis: 0,
      indexUpAxis: 1,
      indexForwardAxis: 2,
    });

    // 앞뒤 휠 위치 (차체 기준)
    const wheelPositions = [
      new CANNON.Vec3(-1.2, 0, 1.0), // 앞 오른쪽
      new CANNON.Vec3(1.2, 0, 1.0),  // 앞 왼쪽
      new CANNON.Vec3(-1.2, 0, -1.1), // 뒤 오른쪽
      new CANNON.Vec3(1.2, 0, -1.1),  // 뒤 왼쪽
    ];

    // 휠 메시 배열
    const wheelMeshes = [];

    wheelPositions.forEach((pos) => {
      wheelOptions.chassisConnectionPointLocal.set(pos.x, pos.y, pos.z);
      vehicle.addWheel(wheelOptions);
      const wheelMesh = createWheel();
      scene.add(wheelMesh);
      wheelMeshes.push(wheelMesh);
    });

    vehicle.addToWorld(world);

    // 바퀴 조향용 변수
    let steeringValue = 0;
    let maxSteerVal = 0.5;
    let maxForce = 4000;
    let brakeForce = 0;

    // 기어 상태 및 가속 관련 변수
    let currentGear = 'P';
    let engineForce = 0;
    let maxEngineForce = 2500;

    // UI 요소들
    const speedDisplay = document.getElementById('hud');
    const timerDisplay = document.getElementById('timerDisplay');
    const gearDisplay = document.getElementById('gearDisplay');

    // 기어 버튼 이벤트
    const gearButtons = {
      P: document.getElementById('gearP'),
      R: document.getElementById('gearR'),
      N: document.getElementById('gearN'),
      D: document.getElementById('gearD'),
    };

    Object.entries(gearButtons).forEach(([gear, btn]) => {
      btn.addEventListener('click', () => {
        currentGear = gear;
        gearDisplay.textContent = `기어: ${gear}`;
        engineForce = 0;
        brakeForce = 0;
      });
    });

    // 조향 버튼 이벤트
    let steerLeft = false;
    let steerRight = false;
    let accelPressed = false;
    let brakePressed = false;

    document.getElementById('btnLeft').addEventListener('mousedown', () => { steerLeft = true; });
    document.getElementById('btnLeft').addEventListener('mouseup', () => { steerLeft = false; });
    document.getElementById('btnLeft').addEventListener('touchstart', e => { e.preventDefault(); steerLeft = true; });
    document.getElementById('btnLeft').addEventListener('touchend', e => { e.preventDefault(); steerLeft = false; });

    document.getElementById('btnRight').addEventListener('mousedown', () => { steerRight = true; });
    document.getElementById('btnRight').addEventListener('mouseup', () => { steerRight = false; });
    document.getElementById('btnRight').addEventListener('touchstart', e => { e.preventDefault(); steerRight = true; });
    document.getElementById('btnRight').addEventListener('touchend', e => { e.preventDefault(); steerRight = false; });

    document.getElementById('btnAccel').addEventListener('mousedown', () => { accelPressed = true; });
    document.getElementById('btnAccel').addEventListener('mouseup', () => { accelPressed = false; });
    document.getElementById('btnAccel').addEventListener('touchstart', e => { e.preventDefault(); accelPressed = true; });
    document.getElementById('btnAccel').addEventListener('touchend', e => { e.preventDefault(); accelPressed = false; });

    document.getElementById('btnBrake').addEventListener('mousedown', () => { brakePressed = true; });
    document.getElementById('btnBrake').addEventListener('mouseup', () => { brakePressed = false; });
    document.getElementById('btnBrake').addEventListener('touchstart', e => { e.preventDefault(); brakePressed = true; });
    document.getElementById('btnBrake').addEventListener('touchend', e => { e.preventDefault(); brakePressed = false; });

    // 속도 계산 함수 (km/h)
    function getVehicleSpeed() {
      const velocity = chassisBody.velocity;
      const forwardWorld = new CANNON.Vec3();
      chassisBody.vectorToWorldFrame(new CANNON.Vec3(0, 0, 1), forwardWorld);
      const speed = velocity.dot(forwardWorld);
      return speed * 3.6; 
    }

    // 시간 카운트용
    let startTime = performance.now();

    // 카메라 업데이트 함수
    function updateCamera() {
      if (cameraFollow) {
        const relativeCameraOffset = new THREE.Vector3(0, 4, 10);
        const cameraOffset = relativeCameraOffset.applyQuaternion(carModel.quaternion).add(carModel.position);
        camera.position.lerp(cameraOffset, 0.1);

        const lookAtPos = new THREE.Vector3();
        lookAtPos.copy(carModel.position);
        lookAtPos.y += 1.5;
        camera.lookAt(lookAtPos);
      } else {
        // 자유 카메라: 마우스 드래그에 따라 yaw/pitch로 카메라 위치 조정
        const distance = 15;
        const offset = new THREE.Vector3();
        offset.x = distance * Math.sin(yaw) * Math.cos(pitch);
        offset.y = distance * Math.sin(pitch) + 4;
        offset.z = distance * Math.cos(yaw) * Math.cos(pitch);

        camera.position.copy(carModel.position).add(offset);
        camera.lookAt(carModel.position.x, carModel.position.y + 1.5, carModel.position.z);
      }
    }

    // 메인 애니메이션 루프
    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);

      const dt = clock.getDelta();
      world.step(1/60, dt);

      // 조향 업데이트
      if (steerLeft) steeringValue = Math.min(steeringValue + 0.02, maxSteerVal);
      else if (steerRight) steeringValue = Math.max(steeringValue - 0.02, -maxSteerVal);
      else steeringValue = steeringValue * 0.85;

      vehicle.setSteeringValue(steeringValue, 0);
      vehicle.setSteeringValue(steeringValue, 1);

      // 기어 및 가속/브레이크 처리
      if (currentGear === 'D') {
        engineForce = accelPressed ? maxEngineForce : 0;
        brakeForce = brakePressed ? maxForce : 0;
      } else if (currentGear === 'R') {
        engineForce = accelPressed ? -maxEngineForce / 2 : 0;
        brakeForce = brakePressed ? maxForce : 0;
      } else if (currentGear === 'N') {
        engineForce = 0;
        brakeForce = brakePressed ? maxForce : 0;
      } else { // P
        engineForce = 0;
        brakeForce = maxForce;
      }

      for (let i = 2; i < 4; i++) {
        vehicle.applyEngineForce(engineForce, i);
        vehicle.setBrake(brakeForce, i);
      }

      // 물리 위치 동기화 (차체)
      carModel.position.copy(chassisBody.position);
      carModel.quaternion.copy(chassisBody.quaternion);

      // 바퀴 위치 동기화
      for (let i = 0; i < vehicle.wheelInfos.length; i++) {
        vehicle.updateWheelTransform(i);
        const t = vehicle.wheelInfos[i].worldTransform;
        const wheelMesh = wheelMeshes[i];
        wheelMesh.position.copy(t.position);
        wheelMesh.quaternion.copy(t.quaternion);
      }

      // 속도 표시
      const speedKmh = getVehicleSpeed();
      speedDisplay.textContent = `속도: ${speedKmh.toFixed(1)} km/h`;

      // 타이머 업데이트
      const elapsed = (performance.now() - startTime) / 1000;
      timerDisplay.textContent = `타이머: ${elapsed.toFixed(2)} s`;

      // 카메라 업데이트
      updateCamera();

      renderer.render(scene, camera);
    }
    animate();

  </script>
</body>
</html>
