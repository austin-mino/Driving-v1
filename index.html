<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>수정된 3D 자동차 게임</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #121212;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      color: white;
    }
    #rotateWarning {
      position: fixed;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.85);
      padding: 25px 40px;
      border-radius: 15px;
      font-size: 1.3rem;
      font-weight: bold;
      z-index: 1000;
      display: none;
    }
    #hud {
      position: fixed;
      top: 20px; left: 20px;
      background: rgba(0,0,0,0.7);
      padding: 12px 18px;
      border-radius: 10px;
      font-weight: 700;
      font-size: 18px;
      user-select: none;
      z-index: 100;
    }
    #gearDisplay {
      position: fixed;
      top: 20px; right: 20px;
      background: rgba(0,0,0,0.7);
      padding: 12px 18px;
      border-radius: 10px;
      font-weight: 700;
      font-size: 18px;
      user-select: none;
      z-index: 100;
    }
    #controlsLeft, #controlsRight {
      position: fixed;
      bottom: 20px;
      display: flex;
      gap: 15px;
      z-index: 100;
      user-select: none;
      flex-wrap: wrap;
    }
    #controlsLeft { left: 20px; }
    #controlsRight { right: 20px; }
    button.controlBtn {
      padding: 14px 20px;
      border-radius: 12px;
      border: none;
      background: #0078d7;
      color: white;
      font-weight: 700;
      font-size: 16px;
      cursor: pointer;
      touch-action: manipulation;
      user-select: none;
    }
    button.controlBtn:active {
      background: #005a9e;
    }
    @media (max-width: 600px) {
      button.controlBtn {
        padding: 18px 22px;
        font-size: 20px;
      }
    }
  </style>
</head>
<body>
  <div id="rotateWarning">가로 모드로 전환해주세요</div>
  <div id="hud">속도: 0 km/h</div>
  <div id="gearDisplay">기어: P</div>

  <div id="controlsLeft">
    <button id="btnLeft" class="controlBtn">◀ 좌</button>
    <button id="btnRight" class="controlBtn">우 ▶</button>
  </div>

  <div id="controlsRight">
    <button id="btnAccel" class="controlBtn">엑셀</button>
    <button id="btnBrake" class="controlBtn">브레이크</button>
    <button id="gearP" class="controlBtn">P</button>
    <button id="gearR" class="controlBtn">R</button>
    <button id="gearN" class="controlBtn">N</button>
    <button id="gearD" class="controlBtn">D</button>
  </div>

  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js';
    import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js';

    const rotateWarning = document.getElementById('rotateWarning');
    const hud = document.getElementById('hud');
    const gearDisplay = document.getElementById('gearDisplay');
    const btnLeft = document.getElementById('btnLeft');
    const btnRight = document.getElementById('btnRight');
    const btnAccel = document.getElementById('btnAccel');
    const btnBrake = document.getElementById('btnBrake');

    function checkOrientation() {
      rotateWarning.style.display = (window.innerHeight > window.innerWidth) ? 'block' : 'none';
    }
    window.addEventListener('resize', checkOrientation);
    window.addEventListener('orientationchange', checkOrientation);
    checkOrientation();

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x222222);

    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 5000);
    camera.position.set(0, 5, 10); // 앞에서 시작

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    const world = new CANNON.World({ gravity: new CANNON.Vec3(0, -9.82, 0) });
    world.broadphase = new CANNON.SAPBroadphase(world);
    world.defaultContactMaterial.friction = 0.6;

    const groundBody = new CANNON.Body({ mass: 0, shape: new CANNON.Plane() });
    groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
    world.addBody(groundBody);

    const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x444444 });
    const groundMesh = new THREE.Mesh(new THREE.PlaneGeometry(1000, 1000), groundMaterial);
    groundMesh.rotation.x = -Math.PI / 2;
    scene.add(groundMesh);

    const chassisBody = new CANNON.Body({ mass: 150 });
    const chassisShape = new CANNON.Box(new CANNON.Vec3(1.5, 0.5, 3));
    chassisBody.addShape(chassisShape);
    chassisBody.position.set(0, 2, 0);
    chassisBody.angularDamping = 0.5;
    world.addBody(chassisBody);

    const carMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
    const carGeometry = new THREE.BoxGeometry(3, 1, 6);
    const carMesh = new THREE.Mesh(carGeometry, carMaterial);
    scene.add(carMesh);

    const vehicle = new CANNON.RaycastVehicle({
      chassisBody: chassisBody,
      indexRightAxis: 0,
      indexUpAxis: 1,
      indexForwardAxis: 2,
    });

    const wheelOptions = {
      radius: 0.5,
      directionLocal: new CANNON.Vec3(0, -1, 0),
      suspensionStiffness: 30,
      suspensionRestLength: 0.3,
      frictionSlip: 5,
      dampingRelaxation: 2.3,
      dampingCompression: 4.4,
      maxSuspensionForce: 100000,
      rollInfluence: 0.01,
      axleLocal: new CANNON.Vec3(-1, 0, 0),
      maxSuspensionTravel: 0.3,
      useCustomSlidingRotationalSpeed: true,
      customSlidingRotationalSpeed: -30,
    };

    const wheelPositions = [
      [-1.2, 0, 2.4],
      [1.2, 0, 2.4],
      [-1.2, 0, -2.4],
      [1.2, 0, -2.4]
    ];
    wheelPositions.forEach((pos, i) => {
      vehicle.addWheel({ ...wheelOptions, chassisConnectionPointLocal: new CANNON.Vec3(...pos), isFrontWheel: i < 2 });
    });

    vehicle.addToWorld(world);

    const wheelMeshes = [];
    vehicle.wheelInfos.forEach((wheel) => {
      const wheelGeo = new THREE.CylinderGeometry(wheel.radius, wheel.radius, 0.4, 32);
      const wheelMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
      const mesh = new THREE.Mesh(wheelGeo, wheelMat);
      mesh.rotation.z = Math.PI / 2;
      scene.add(mesh);
      wheelMeshes.push(mesh);
    });

    const ambient = new THREE.AmbientLight(0xffffff, 0.4);
    scene.add(ambient);
    const light = new THREE.DirectionalLight(0xffffff, 0.8);
    light.position.set(10, 30, 20);
    scene.add(light);

    let engineForce = 0;
    let brakeForce = 0;
    const maxEngineForce = 5000;
    const maxBrakeForce = 400;
    const maxSteerVal = Math.PI / 8;
    let steeringValue = 0;

    let gearState = 'P';
    function updateGearDisplay() {
      gearDisplay.textContent = `기어: ${gearState}`;
    }

    document.getElementById('gearP').onclick = () => {
      gearState = 'P';
      updateGearDisplay();
      applyBrake(1e5);
      engineForce = 0;
    };
    document.getElementById('gearR').onclick = () => {
      gearState = 'R';
      updateGearDisplay();
    };
    document.getElementById('gearN').onclick = () => {
      gearState = 'N';
      updateGearDisplay();
    };
    document.getElementById('gearD').onclick = () => {
      gearState = 'D';
      updateGearDisplay();
    };
    updateGearDisplay();

    function applyBrake(force) {
      for (let i = 0; i < 4; i++) vehicle.setBrake(force, i);
    }

    const input = { left: false, right: false, accel: false, brake: false };
    const bindBtn = (btn, key) => {
      btn.addEventListener('mousedown', () => input[key] = true);
      btn.addEventListener('mouseup', () => input[key] = false);
      btn.addEventListener('touchstart', e => { e.preventDefault(); input[key] = true; });
      btn.addEventListener('touchend', e => { e.preventDefault(); input[key] = false; });
    };
    bindBtn(btnLeft, 'left');
    bindBtn(btnRight, 'right');
    bindBtn(btnAccel, 'accel');
    bindBtn(btnBrake, 'brake');

    const clock = new THREE.Clock();
    function animate() {
      const delta = clock.getDelta();

      if (gearState === 'P') {
        applyBrake(1e5);
        engineForce = 0;
      } else {
        applyBrake(input.brake ? maxBrakeForce : 0);
        if (gearState === 'D') engineForce = input.accel ? maxEngineForce : 0;
        if (gearState === 'R') engineForce = input.accel ? -maxEngineForce * 0.6 : 0;
      }

      steeringValue = input.left ? maxSteerVal : input.right ? -maxSteerVal : 0;

      for (let i = 0; i < vehicle.wheelInfos.length; i++) {
        if (vehicle.wheelInfos[i].isFrontWheel) vehicle.setSteeringValue(steeringValue, i);
        vehicle.applyEngineForce(engineForce, i);
      }

      world.step(1 / 60, delta);

      carMesh.position.copy(chassisBody.position);
      carMesh.quaternion.copy(chassisBody.quaternion);

      vehicle.wheelInfos.forEach((wheel, i) => {
        vehicle.updateWheelTransform(i);
        wheelMeshes[i].position.copy(wheel.worldTransform.position);
        wheelMeshes[i].quaternion.copy(wheel.worldTransform.quaternion);
      });

      // 카메라를 자동차 앞에서 뒤를 보도록
      const offset = new THREE.Vector3(0, 5, 10).applyQuaternion(carMesh.quaternion);
      camera.position.lerp(carMesh.position.clone().add(offset), 0.1);
      const backward = new THREE.Vector3(0, 0, -1).applyQuaternion(carMesh.quaternion);
      camera.lookAt(carMesh.position.clone().add(backward.multiplyScalar(15)));

      hud.textContent = `속도: ${Math.round(chassisBody.velocity.length() * 3.6)} km/h`;

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    animate();
  </script>
</body>
</html>
