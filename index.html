<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>3D 자동차 게임 with 물리엔진 & 기어</title>
<style>
  body { margin:0; overflow:hidden; background:#000; color:#fff; font-family: Arial,sans-serif; }
  #hud {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.7);
    padding: 10px 20px;
    border-radius: 10px;
    font-weight: bold;
    font-size: 18px;
    z-index: 100;
  }
  #buttons {
    position: fixed;
    bottom: 80px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 15px;
    z-index: 100;
  }
  button {
    font-size: 16px;
    padding: 12px 20px;
    border-radius: 10px;
    border: none;
    background: #4f9eff;
    color: white;
    font-weight: bold;
    cursor: pointer;
    user-select: none;
  }
  #gearSelector {
    position: fixed;
    top: 20px;
    right: 20px;
    background: #222;
    border-radius: 12px;
    padding: 10px;
    display: flex;
    flex-direction: column;
    gap: 8px;
    z-index: 100;
  }
  #gearSelector button {
    background: #555;
  }
  #gearSelector button.active {
    background: #ff9b00;
    color: black;
  }
</style>
</head>
<body>

<div id="hud">
  <div id="speedText">속도: 0 km/h</div>
  <div id="gearText">기어: P</div>
</div>

<div id="buttons">
  <button id="leftBtn">◀ 좌</button>
  <button id="rightBtn">우 ▶</button>
  <button id="accelBtn">엑셀</button>
  <button id="brakeBtn">브레이크</button>
</div>

<div id="gearSelector">
  <button data-gear="P" class="active">P</button>
  <button data-gear="R">R</button>
  <button data-gear="N">N</button>
  <button data-gear="D">D</button>
</div>

<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js';
import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js';

const speedText = document.getElementById('speedText');
const gearText = document.getElementById('gearText');
const buttons = {
  left: document.getElementById('leftBtn'),
  right: document.getElementById('rightBtn'),
  accel: document.getElementById('accelBtn'),
  brake: document.getElementById('brakeBtn'),
};
const gearButtons = [...document.querySelectorAll('#gearSelector button')];

let currentGear = 'P';

gearButtons.forEach(btn => {
  btn.addEventListener('click', () => {
    gearButtons.forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    currentGear = btn.dataset.gear;
    gearText.textContent = `기어: ${currentGear}`;
  });
});

// Three.js Setup
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x222222);
const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0, 5, -12);

const renderer = new THREE.WebGLRenderer({antialias: true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

// Lighting
scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 0.7));
const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
dirLight.position.set(5, 10, -5);
scene.add(dirLight);

// Cannon-es Physics World
const world = new CANNON.World({
  gravity: new CANNON.Vec3(0, -9.82, 0)
});
world.broadphase = new CANNON.SAPBroadphase(world);
world.defaultContactMaterial.friction = 0.6;

// Ground
const groundShape = new CANNON.Plane();
const groundBody = new CANNON.Body({ mass: 0, shape: groundShape });
groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
world.addBody(groundBody);

const groundMesh = new THREE.Mesh(
  new THREE.PlaneGeometry(500, 500),
  new THREE.MeshStandardMaterial({ color: 0x444444 })
);
groundMesh.rotation.x = -Math.PI / 2;
scene.add(groundMesh);

// Car chassis body
const chassisShape = new CANNON.Box(new CANNON.Vec3(1.5, 0.5, 3));
const chassisBody = new CANNON.Body({ mass: 150 });
chassisBody.addShape(chassisShape);
chassisBody.position.set(0, 1, 0);
world.addBody(chassisBody);

// Visual chassis mesh
const chassisMesh = new THREE.Mesh(
  new THREE.BoxGeometry(3, 1, 6),
  new THREE.MeshStandardMaterial({ color: 0xff2222, metalness: 0.6, roughness: 0.4 })
);
scene.add(chassisMesh);

// Create vehicle
const vehicle = new CANNON.RaycastVehicle({
  chassisBody: chassisBody,
  indexUpAxis: 1,
  indexRightAxis: 0,
  indexForwardAxis: 2,
});

const wheelOptions = {
  radius: 0.6,
  directionLocal: new CANNON.Vec3(0, -1, 0),
  suspensionStiffness: 30,
  suspensionRestLength: 0.3,
  axleLocal: new CANNON.Vec3(-1, 0, 0),
  frictionSlip: 4,
  dampingRelaxation: 2.3,
  dampingCompression: 4.4,
  maxSuspensionForce: 1e4,
  rollInfluence: 0.01,
  maxSuspensionTravel: 0.3,
  customSlidingRotationalSpeed: -30,
  useCustomSlidingRotationalSpeed: true,
};

// Add wheels (2 front, 2 back)
vehicle.addWheel({ ...wheelOptions, chassisConnectionPointLocal: new CANNON.Vec3(-1.2, 0, 2.4), isFrontWheel: true });
vehicle.addWheel({ ...wheelOptions, chassisConnectionPointLocal: new CANNON.Vec3(1.2, 0, 2.4), isFrontWheel: true });
vehicle.addWheel({ ...wheelOptions, chassisConnectionPointLocal: new CANNON.Vec3(-1.2, 0, -2.4), isFrontWheel: false });
vehicle.addWheel({ ...wheelOptions, chassisConnectionPointLocal: new CANNON.Vec3(1.2, 0, -2.4), isFrontWheel: false });

vehicle.addToWorld(world);

// Create wheel meshes
const wheelMeshes = [];
vehicle.wheelInfos.forEach(wheel => {
  const mesh = new THREE.Mesh(
    new THREE.CylinderGeometry(wheel.radius, wheel.radius, 0.4, 24),
    new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.7, roughness: 0.6 })
  );
  mesh.rotation.z = Math.PI / 2;
  scene.add(mesh);
  wheelMeshes.push(mesh);
});

// Controls state
const key = {
  left: false,
  right: false,
  accel: false,
  brake: false,
};

// Event listeners for buttons
function bindBtn(btn, prop) {
  btn.addEventListener('pointerdown', () => key[prop] = true);
  btn.addEventListener('pointerup', () => key[prop] = false);
  btn.addEventListener('pointerleave', () => key[prop] = false);
  btn.addEventListener('touchstart', e => { e.preventDefault(); key[prop] = true; }, { passive: false });
  btn.addEventListener('touchend', () => key[prop] = false);
}
bindBtn(buttons.left, 'left');
bindBtn(buttons.right, 'right');
bindBtn(buttons.accel, 'accel');
bindBtn(buttons.brake, 'brake');

const maxSteerVal = Math.PI / 6; // 30도
const maxForce = 3500;
const maxBrakeForce = 100;

let steerValue = 0;

function animate() {
  requestAnimationFrame(animate);

  // Steering logic (smooth)
  if (key.left) {
    steerValue += 0.02;
    if (steerValue > maxSteerVal) steerValue = maxSteerVal;
  } else if (key.right) {
    steerValue -= 0.02;
    if (steerValue < -maxSteerVal) steerValue = -maxSteerVal;
  } else {
    steerValue *= 0.8; // 천천히 복귀
    if (Math.abs(steerValue) < 0.01) steerValue = 0;
  }

  vehicle.setSteeringValue(steerValue, 0);
  vehicle.setSteeringValue(steerValue, 1);

  // Engine force and braking based on gear
  let engineForce = 0;
  let brakeForce = 0;
  if (currentGear === 'D') {
    if (key.accel) engineForce = maxForce;
    if (key.brake) brakeForce = maxBrakeForce;
  } else if (currentGear === 'R') {
    if (key.accel) engineForce = -maxForce * 0.7;
    if (key.brake) brakeForce = maxBrakeForce;
  } else if (currentGear === 'P' || currentGear === 'N') {
    if (key.brake) brakeForce = maxBrakeForce;
  }

  vehicle.applyEngineForce(engineForce, 2);
  vehicle.applyEngineForce(engineForce, 3);

  for(let i=0; i<4; i++) {
    vehicle.setBrake(brakeForce, i);
  }

  // Step physics world
  world.step(1 / 60);

  // Sync chassis mesh
  chassisMesh.position.copy(chassisBody.position);
  chassisMesh.quaternion.copy(chassisBody.quaternion);

  // Sync wheels
  for (let i = 0; i < vehicle.wheelInfos.length; i++) {
    vehicle.updateWheelTransform(i);
    const t = vehicle.wheelInfos[i].worldTransform;
    wheelMeshes[i].position.copy(t.position);
    wheelMeshes[i].quaternion.copy(t.quaternion);
  }

  // Camera follow behind the car smoothly
  const relativeCameraOffset = new THREE.Vector3(0, 5, -12);
  const cameraOffset = relativeCameraOffset.applyMatrix4(chassisMesh.matrixWorld);

  camera.position.lerp(cameraOffset, 0.1);
  camera.lookAt(chassisMesh.position);

  // Update speed display (m/s to km/h)
  const speed = chassisBody.velocity.length() * 3.6;
  speedText.textContent = `속도: ${Math.round(speed)} km/h`;

  renderer.render(scene, camera);
}

animate();
</script>

</body>
</html>
