<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>3D driving</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #121212;
      font-family: 'Segoe UI', Tahoma, Verdana, sans-serif;
      color: #fff;
      user-select: none;
    }
    #rotateWarning {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.85);
      padding: 25px 40px;
      border-radius: 15px;
      font-size: 1.3rem;
      font-weight: bold;
      z-index: 1000;
      display: none;
    }
    #hud, #gearDisplay, #timerDisplay {
      position: fixed;
      background: rgba(0, 0, 0, 0.7);
      padding: 12px 18px;
      border-radius: 10px;
      font-weight: 700;
      font-size: 18px;
      user-select: none;
      z-index: 100;
    }
    #hud { top: 20px; left: 20px; }
    #gearDisplay { top: 10px; right: 20px; }
    #timerDisplay { top: 60px; left: 20px; }
    #gearControls {
      position: fixed;
      top: 50px;
      right: 20px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      z-index: 100;
    }
    #cameraToggleBtn {
      margin-top: 10px;
      padding: 10px 16px;
      font-weight: 700;
      font-size: 14px;
      border-radius: 12px;
      background: #0078d7;
      color: #fff;
      border: none;
      cursor: pointer;
      user-select: none;
      transition: background-color 0.2s;
    }
    #cameraToggleBtn:active {
      background: #005a9e;
    }
    #controlsLeft, #driveControls {
      position: fixed;
      bottom: 20px;
      display: flex;
      gap: 15px;
      z-index: 100;
      user-select: none;
    }
    #controlsLeft { left: 20px; }
    #driveControls { right: 20px; }
    button.controlBtn {
      padding: 14px 20px;
      border-radius: 12px;
      border: none;
      background: #0078d7;
      color: #fff;
      font-weight: 700;
      font-size: 16px;
      cursor: pointer;
      touch-action: manipulation;
      transition: background-color 0.2s, color 0.2s;
    }
    button.controlBtn:active {
      background: #005a9e;
    }
    @media (max-width: 600px) {
      button.controlBtn {
        padding: 18px 22px;
        font-size: 20px;
      }
      #cameraToggleBtn {
        font-size: 16px;
        padding: 14px 20px;
      }
    }
  </style>
</head>
<body>
  <div id="rotateWarning">가로 모드로 전환해주세요</div>
  <div id="hud">속도: 0 km/h</div>
  <div id="timerDisplay">타이머: 0.00 s</div>
  <div id="gearDisplay">기어: P</div>

  <!-- 좌/우 스티어링 -->
  <div id="controlsLeft">
    <button id="btnLeft" class="controlBtn">◀ 좌</button>
    <button id="btnRight" class="controlBtn">우 ▶</button>
  </div>
  <!-- 엑셀·브레이크 -->
  <div id="driveControls">
    <button id="btnAccel" class="controlBtn">엑셀</button>
    <button id="btnBrake" class="controlBtn">브레이크</button>
  <div id="reset">
    <!-- 기어 선택 아래에 추가 -->
    <button id="btnReset" class="controlBtn">차량 리셋</button>
  </div>
    <!-- 기어 선택 -->
  <div id="gearControls">
    <button id="gearP" class="controlBtn">P</button>
    <button id="gearR" class="controlBtn">R</button>
    <button id="gearN" class="controlBtn">N</button>
    <button id="gearD" class="controlBtn">D</button>
    <button id="cameraToggleBtn" title="카메라 모드 토글">뒤 따라가기 ON</button>
  </div>

  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js';
    import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js';

    // 1. renderer 선언 및 초기화 (최상단에서 딱 한번)
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // 2. renderer.domElement 이벤트 등록
    let isDragging = false;
    let previousMousePosition = { x: 0, y: 0 };
    let yaw = 0;
    let pitch = 0.15; // 약간 위를 보는 초기값
    const sensitivity = 0.005;

    renderer.domElement.addEventListener('mousedown', (event) => {
      if (event.button === 0) {
        isDragging = true;
        previousMousePosition.x = event.clientX;
        previousMousePosition.y = event.clientY;
      }
    });
    renderer.domElement.addEventListener('mouseup', (event) => {
      if (event.button === 0) {
        isDragging = false;
      }
    });
    renderer.domElement.addEventListener('mousemove', (event) => {
      if (!isDragging) return;

      const deltaMove = {
        x: event.clientX - previousMousePosition.x,
        y: event.clientY - previousMousePosition.y
      };

      yaw -= deltaMove.x * sensitivity;
      pitch -= deltaMove.y * sensitivity;

      const pitchLimit = Math.PI / 3;
      pitch = Math.max(-pitchLimit, Math.min(pitchLimit, pitch));

      previousMousePosition.x = event.clientX;
      previousMousePosition.y = event.clientY;
    });

    // 가로모드 체크
    const rotateWarning = document.getElementById('rotateWarning');
    function checkOrientation() {
      rotateWarning.style.display = window.innerHeight > window.innerWidth ? 'block' : 'none';
    }
    window.addEventListener('resize', checkOrientation);
    window.addEventListener('orientationchange', checkOrientation);
    checkOrientation();

    // Three.js 기본 설정
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x222222);
    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.05, 5000);
    camera.position.set(0, 5, 15);
    camera.lookAt(0, 0, 0);

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // reset 버튼 이벤트
    document.getElementById('btnReset').addEventListener('click', resetCar);
    window.addEventListener('keydown', e => {
      if (e.key.toLowerCase() === 'r') resetCar();
    });

    function resetCar() {
      const pos = chassisBody.position;
      chassisBody.position.set(pos.x, pos.y + 1.5, pos.z);
      const yRot = getYRotation(chassisBody.quaternion);
      chassisBody.quaternion.setFromEuler(0, yRot, 0);
      chassisBody.velocity.set(0, 0, 0);
      chassisBody.angularVelocity.set(0, 0, 0);
    }

    function getYRotation(q) {
      const siny_cosp = 2 * (q.w * q.y + q.z * q.x);
      const cosy_cosp = 1 - 2 * (q.y * q.y + q.z * q.z);
      return Math.atan2(siny_cosp, cosy_cosp);
    }

    // ───────────────────────────────────────────────
    // 1. 월드 설정
    const world = new CANNON.World({ gravity: new CANNON.Vec3(0, -9.82, 0) });
    world.broadphase = new CANNON.SAPBroadphase(world);
    world.defaultContactMaterial.friction = 0.6;

    // 2. 지면 생성
    const groundBody = new CANNON.Body({ mass: 0 });
    groundBody.addShape(new CANNON.Plane());
    groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
    world.addBody(groundBody);

    // 3. 트랙 타원 파라미터
    const trackA = 500;  // x 방향 반지름
    const trackB = 60;   // z 방향 반지름
    const trackWidth = 60;
    const numSegments = 400; // 트랙 구성 정밀도

    // 4. 바리어 생성
    const barrierHeight = 1;
    const barrierThickness = 1;
    const barrierLength = 25;

    const barrierMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
    const barrierMeshes = [];

    for (let i = 0; i < numSegments; i++) {
      const angle = (i / numSegments) * 2 * Math.PI;

      const cx = Math.cos(angle);
      const sz = Math.sin(angle);

      const innerX = (trackA - trackWidth / 2) * cx;
      const innerZ = (trackB - trackWidth / 2) * sz;

      const outerX = (trackA + trackWidth / 2) * cx;
      const outerZ = (trackB + trackWidth / 2) * sz;

      const rotationY = -Math.atan2(
        (trackB * Math.cos(angle)),
        (-trackA * Math.sin(angle))
      );

      // 왼쪽(안쪽) 바리어
      [innerX, innerZ].forEach((_, index) => {
        const isInner = index === 0;
        const x = isInner ? innerX : outerX;
        const z = isInner ? innerZ : outerZ;

        const barrierShape = new CANNON.Box(new CANNON.Vec3(barrierLength / 2, barrierHeight / 2, barrierThickness / 2));
        const barrierBody = new CANNON.Body({ mass: 0 });
        barrierBody.addShape(barrierShape);
        barrierBody.position.set(x, barrierHeight / 3, z);
        barrierBody.quaternion.setFromEuler(0, rotationY, 0);
        world.addBody(barrierBody);

        const barrierGeom = new THREE.BoxGeometry(barrierLength, barrierHeight, barrierThickness);
        const barrierMesh = new THREE.Mesh(barrierGeom, barrierMat);
        barrierMesh.position.copy(barrierBody.position);
        barrierMesh.quaternion.copy(barrierBody.quaternion);
        scene.add(barrierMesh);
        barrierMeshes.push(barrierMesh);
      });
    }
    const trackShape = new THREE.Shape();
    for (let i = 0; i <= numSegments; i++) {
      const angle = (i / numSegments) * 2 * Math.PI;
      const x = trackA * Math.cos(angle);
      const z = trackB * Math.sin(angle);
      if (i === 0) {
        trackShape.moveTo(x, z);
      } else {
        trackShape.lineTo(x, z);
      }
    }
    const extrudeSettings = { depth:0.1, bevelEnabled: false };
    const geometry = new THREE.ExtrudeGeometry(trackShape, extrudeSettings);
    const material = new THREE.MeshStandardMaterial({ color: 0x222222 });
    const mesh = new THREE.Mesh(geometry, material);
    mesh.rotation.x = -Math.PI / 2;
    mesh.position.y = -trackWidth / 2;
    scene.add(mesh);

    // 자동차 차체 물리 (박스)
    const chassisShape = new CANNON.Box(new CANNON.Vec3(1.5, 0.5, 3));
    const chassisBody = new CANNON.Body({ mass: 110 });
    chassisBody.addShape(chassisShape);
    chassisBody.position.set(500, 0.5, 0);
    chassisBody.angularDamping = 0.5;
    chassisBody.linearDamping = 0.0;
    world.addBody(chassisBody);

    // 자동차 시각 모델 (둥근 차체)
    const carModel = createGrandeurIGCarDetailed();
    scene.add(carModel);

    function createGrandeurIGCarDetailed() {
      const g = new THREE.Group();

      const paint = new THREE.MeshStandardMaterial({ color: 0xe8e8e8, metalness: 0.6, roughness: 0.2 });
      const chrome = new THREE.MeshStandardMaterial({ color: 0xd0d0d0, metalness: 1.0, roughness: 0.05 });
      const black = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.8 });
      const glass = new THREE.MeshStandardMaterial({ color: 0x336688, transparent: true, opacity: 0.5, roughness: 0.1 });
      const headMat = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xffffff, emissiveIntensity: 1 });
      const tailMat = new THREE.MeshStandardMaterial({ color: 0xff1100, emissive: 0xff1100, emissiveIntensity: 0.8 });

      const sideShape = new THREE.Shape();
      sideShape.moveTo(-2.3, -1.1);
      sideShape.bezierCurveTo(-2.3, 0.5, -1.8, 1.8, 0, 2.0);
      sideShape.bezierCurveTo(1.8, 1.8, 2.3, 0.5, 2.3, -1.1);
      sideShape.lineTo(2.3, -1.3);
      sideShape.lineTo(-2.3, -1.3);
      sideShape.lineTo(-2.3, -1.1);
      const bodyGeo = new THREE.ExtrudeGeometry(sideShape, { depth: 13.8, bevelEnabled: false });
      g.rotation.x = Math.PI / 2;
      g.position.y = 0.5;
      g.position.z = -28;
      bodyGeo.translate(0, 0.6, 0);
      g.add(new THREE.Mesh(bodyGeo, paint));

      const hoodShape = new THREE.Shape();
      hoodShape.moveTo(-2.2, 0);
      hoodShape.bezierCurveTo(-2, 0.5, 2, 0.5, 2.2, 0);
      hoodShape.lineTo(2.2, 1.3);
      hoodShape.lineTo(-2.2, 1.3);
      hoodShape.lineTo(-2.2, 0);
      const hoodGeo = new THREE.ExtrudeGeometry(hoodShape, { depth: 2.7, bevelEnabled: false });
      hoodGeo.rotateX(Math.PI / 2);
      hoodGeo.translate(0, 0.9, 0);
      g.add(new THREE.Mesh(hoodGeo, paint));

      const trunkShape = new THREE.Shape();
      trunkShape.moveTo(-2.1, 0);
      trunkShape.bezierCurveTo(-1.8, 0.4, 1.8, 0.4, 2.1, 0);
      trunkShape.lineTo(2.1, 1.1);
      trunkShape.lineTo(-2.1, 1.1);
      trunkShape.lineTo(-2.1, 0);
      const trunkGeo = new THREE.ExtrudeGeometry(trunkShape, { depth: 2.4, bevelEnabled: false });
      trunkGeo.rotateX(Math.PI / 2);
      trunkGeo.translate(0, 0.7, -11.5);
      g.add(new THREE.Mesh(trunkGeo, paint));

      // 윈도우
      const windowShape = new THREE.Shape();
      windowShape.moveTo(-2, -0.3);
      windowShape.bezierCurveTo(-2, 0.5, 2, 0.5, 2, -0.3);
      windowShape.lineTo(2, 0.5);
      windowShape.lineTo(-2, 0.5);
      windowShape.lineTo(-2, -0.3);
      const windowGeo = new THREE.ExtrudeGeometry(windowShape, { depth: 6, bevelEnabled: false });
      windowGeo.rotateX(Math.PI / 2);
      windowGeo.translate(0, 1.2, -2.9);
      g.add(new THREE.Mesh(windowGeo, glass));

      // 앞 유리
      const frontGlassShape = new THREE.Shape();
      frontGlassShape.moveTo(-2.1, 0);
      frontGlassShape.bezierCurveTo(-1.5, 2, 1.5, 2, 2.1, 0);
      frontGlassShape.lineTo(2.1, 0.5);
      frontGlassShape.lineTo(-2.1, 0.5);
      frontGlassShape.lineTo(-2.1, 0);
      const frontGlassGeo = new THREE.ExtrudeGeometry(frontGlassShape, { depth: 0.4, bevelEnabled: false });
      frontGlassGeo.rotateX(Math.PI / 2);
      frontGlassGeo.translate(0, 2, 5.5);
      g.add(new THREE.Mesh(frontGlassGeo, glass));

      // 뒷 유리
      const rearGlassShape = new THREE.Shape();
      rearGlassShape.moveTo(-2, 0);
      rearGlassShape.bezierCurveTo(-1.5, 1.4, 1.5, 1.4, 2, 0);
      rearGlassShape.lineTo(2, 0.5);
      rearGlassShape.lineTo(-2, 0.5);
      rearGlassShape.lineTo(-2, 0);
      const rearGlassGeo = new THREE.ExtrudeGeometry(rearGlassShape, { depth: 0.4, bevelEnabled: false });
      rearGlassGeo.rotateX(Math.PI / 2);
      rearGlassGeo.translate(0, 2, -13);
      g.add(new THREE.Mesh(rearGlassGeo, glass));

      // 앞 헤드라이트
      const headLightGeo = new THREE.BoxGeometry(0.6, 0.15, 0.2);
      const headLight1 = new THREE.Mesh(headLightGeo, headMat);
      headLight1.position.set(-1.2, 0.2, 6.8);
      g.add(headLight1);
      const headLight2 = headLight1.clone();
      headLight2.position.x = 1.2;
      g.add(headLight2);

      // 뒤 테일라이트
      const tailLightGeo = new THREE.BoxGeometry(0.6, 0.15, 0.3);
      const tailLight1 = new THREE.Mesh(tailLightGeo, tailMat);
      tailLight1.position.set(-1.2, 0.2, -14.2);
      g.add(tailLight1);
      const tailLight2 = tailLight1.clone();
      tailLight2.position.x = 1.2;
      g.add(tailLight2);

      // 휠
      const wheelGeo = new THREE.CylinderGeometry(1.0, 1.0, 0.4, 24);
      wheelGeo.rotateZ(Math.PI / 2);
      const wheelMat = new THREE.MeshStandardMaterial({ color: 0x101010, roughness: 0.6, metalness: 0.4 });

      const wheelPositions = [
        [1.6, -0.6, 6.2], // 앞 오른쪽
        [-1.6, -0.6, 6.2], // 앞 왼쪽
        [1.6, -0.6, -10.5], // 뒤 오른쪽
        [-1.6, -0.6, -10.5]  // 뒤 왼쪽
      ];
      for (const pos of wheelPositions) {
        const wheelMesh = new THREE.Mesh(wheelGeo, wheelMat);
        wheelMesh.position.set(...pos);
        g.add(wheelMesh);
      }
      return g;
    }

    // 자동차 바퀴 물리 생성
    const options = {
      radius: 1,
      directionLocal: new CANNON.Vec3(0, -1, 0),
      suspensionStiffness: 35,
      suspensionRestLength: 0.3,
      frictionSlip: 5,
      dampingRelaxation: 2.3,
      dampingCompression: 4.4,
      maxSuspensionForce: 100000,
      rollInfluence: 0.01,
      axleLocal: new CANNON.Vec3(-1, 0, 0),
      chassisConnectionPointLocal: new CANNON.Vec3(),
      maxSuspensionTravel: 0.3,
      customSlidingRotationalSpeed: -30,
      useCustomSlidingRotationalSpeed: true,
    };

    // 차량 레이캐스트 바퀴용 객체
    const vehicle = new CANNON.RaycastVehicle({
      chassisBody: chassisBody,
      indexRightAxis: 0,
      indexUpAxis: 1,
      indexForwardAxis: 2,
    });

    const wheelPositionsCannon = [
      new CANNON.Vec3(-1.6, 0, 6.2),
      new CANNON.Vec3(1.6, 0, 6.2),
      new CANNON.Vec3(-1.6, 0, -10.5),
      new CANNON.Vec3(1.6, 0, -10.5),
    ];

    for (let i = 0; i < wheelPositionsCannon.length; i++) {
      options.chassisConnectionPointLocal.set(
        wheelPositionsCannon[i].x,
        wheelPositionsCannon[i].y,
        wheelPositionsCannon[i].z
      );
      vehicle.addWheel(options);
    }

    vehicle.addToWorld(world);

    // 각 바퀴용 메쉬 생성
    const wheelMeshes = [];
    for (let i = 0; i < vehicle.wheelInfos.length; i++) {
      const wheelGeo = new THREE.CylinderGeometry(options.radius, options.radius, 0.4, 24);
      wheelGeo.rotateZ(Math.PI / 2);
      const wheelMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.7, metalness: 0.3 });
      const wheelMesh = new THREE.Mesh(wheelGeo, wheelMat);
      scene.add(wheelMesh);
      wheelMeshes.push(wheelMesh);
    }

    // 조명 추가
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
    directionalLight.position.set(30, 50, 30);
    directionalLight.castShadow = true;
    scene.add(directionalLight);

    // --------------------
    // 입력 처리
    const inputState = {
      left: false,
      right: false,
      accel: false,
      brake: false,
    };

    // 키보드 이벤트
    window.addEventListener('keydown', (e) => {
      switch (e.code) {
        case 'ArrowLeft':
        case 'KeyA':
          inputState.left = true;
          break;
        case 'ArrowRight':
        case 'KeyD':
          inputState.right = true;
          break;
        case 'ArrowUp':
        case 'KeyW':
          inputState.accel = true;
          break;
        case 'ArrowDown':
        case 'KeyS':
          inputState.brake = true;
          break;
      }
    });

    window.addEventListener('keyup', (e) => {
      switch (e.code) {
        case 'ArrowLeft':
        case 'KeyA':
          inputState.left = false;
          break;
        case 'ArrowRight':
        case 'KeyD':
          inputState.right = false;
          break;
        case 'ArrowUp':
        case 'KeyW':
          inputState.accel = false;
          break;
        case 'ArrowDown':
        case 'KeyS':
          inputState.brake = false;
          break;
      }
    });

    // 터치 버튼 이벤트 연결
    document.getElementById('btnLeft').addEventListener('touchstart', e => {
      e.preventDefault();
      inputState.left = true;
    });
    document.getElementById('btnLeft').addEventListener('touchend', e => {
      e.preventDefault();
      inputState.left = false;
    });
    document.getElementById('btnRight').addEventListener('touchstart', e => {
      e.preventDefault();
      inputState.right = true;
    });
    document.getElementById('btnRight').addEventListener('touchend', e => {
      e.preventDefault();
      inputState.right = false;
    });
    document.getElementById('btnAccel').addEventListener('touchstart', e => {
      e.preventDefault();
      inputState.accel = true;
    });
    document.getElementById('btnAccel').addEventListener('touchend', e => {
      e.preventDefault();
      inputState.accel = false;
    });
    document.getElementById('btnBrake').addEventListener('touchstart', e => {
      e.preventDefault();
      inputState.brake = true;
    });
    document.getElementById('btnBrake').addEventListener('touchend', e => {
      e.preventDefault();
      inputState.brake = false;
    });

    // 기어 상태 및 UI
    let currentGear = 'P';
    const gearDisplay = document.getElementById('gearDisplay');

    function setGear(gear) {
      currentGear = gear;
      gearDisplay.textContent = '기어: ' + gear;
    }

    document.getElementById('gearP').addEventListener('click', () => setGear('P'));
    document.getElementById('gearR').addEventListener('click', () => setGear('R'));
    document.getElementById('gearN').addEventListener('click', () => setGear('N'));
    document.getElementById('gearD').addEventListener('click', () => setGear('D'));

    // 카메라 토글 버튼 및 상태
    let followCamera = true;
    const cameraToggleBtn = document.getElementById('cameraToggleBtn');
    cameraToggleBtn.addEventListener('click', () => {
      followCamera = !followCamera;
      cameraToggleBtn.textContent = followCamera ? '뒤 따라가기 ON' : '뒤 따라가기 OFF';
    });

    // 타이머 관련
    const timerDisplay = document.getElementById('timerDisplay');
    let startTime = performance.now();
    let elapsedTime = 0;

    // 차량 속도계 표시
    const hud = document.getElementById('hud');

    // 차량 구동 및 조작
    const maxSteerVal = 0.5;
    const maxForce = 500;
    const brakeForce = 1000000;

    function applyControls() {
      // 조향
      if (inputState.left) {
        vehicle.setSteeringValue(maxSteerVal, 0);
        vehicle.setSteeringValue(maxSteerVal, 1);
      } else if (inputState.right) {
        vehicle.setSteeringValue(-maxSteerVal, 0);
        vehicle.setSteeringValue(-maxSteerVal, 1);
      } else {
        vehicle.setSteeringValue(0, 0);
        vehicle.setSteeringValue(0, 1);
      }

      // 구동 및 브레이크
      if (currentGear === 'D') {
        if (inputState.accel) {
          vehicle.applyEngineForce(-maxForce, 2);
          vehicle.applyEngineForce(-maxForce, 3);
        } else {
          vehicle.applyEngineForce(0, 2);
          vehicle.applyEngineForce(0, 3);
        }
        if (inputState.brake) {
          vehicle.setBrake(brakeForce, 0);
          vehicle.setBrake(brakeForce, 1);
          vehicle.setBrake(brakeForce, 2);
          vehicle.setBrake(brakeForce, 3);
        } else {
          vehicle.setBrake(0, 0);
          vehicle.setBrake(0, 1);
          vehicle.setBrake(0, 2);
          vehicle.setBrake(0, 3);
        }
      } else if (currentGear === 'R') {
        if (inputState.accel) {
          vehicle.applyEngineForce(maxForce, 2);
          vehicle.applyEngineForce(maxForce, 3);
        } else {
          vehicle.applyEngineForce(0, 2);
          vehicle.applyEngineForce(0, 3);
        }
        if (inputState.brake) {
          vehicle.setBrake(brakeForce, 0);
          vehicle.setBrake(brakeForce, 1);
          vehicle.setBrake(brakeForce, 2);
          vehicle.setBrake(brakeForce, 3);
        } else {
          vehicle.setBrake(0, 0);
          vehicle.setBrake(0, 1);
          vehicle.setBrake(0, 2);
          vehicle.setBrake(0, 3);
        }
      } else {
        // P, N 상태는 무력화
        vehicle.applyEngineForce(0, 0);
        vehicle.applyEngineForce(0, 1);
        vehicle.applyEngineForce(0, 2);
        vehicle.applyEngineForce(0, 3);
        vehicle.setBrake(brakeForce, 0);
        vehicle.setBrake(brakeForce, 1);
        vehicle.setBrake(brakeForce, 2);
        vehicle.setBrake(brakeForce, 3);
      }
    }

    // 애니메이션 루프
    let lastTime;
    function animate(time) {
      requestAnimationFrame(animate);

      if (!lastTime) lastTime = time;
      const dt = (time - lastTime) / 1000;
      lastTime = time;

      world.step(1 / 60, dt);

      // 차량 물리 위치/회전 동기화
      carModel.position.copy(chassisBody.position);
      carModel.quaternion.copy(chassisBody.quaternion);

      // 바퀴 위치 업데이트
      for (let i = 0; i < vehicle.wheelInfos.length; i++) {
        vehicle.updateWheelTransform(i);
        const t = vehicle.wheelInfos[i].worldTransform;
        wheelMeshes[i].position.copy(t.position);
        wheelMeshes[i].quaternion.copy(t.quaternion);
      }

      // 차량 속도 (km/h)
      const velocity = chassisBody.velocity.length();
      const speedKmh = Math.round(velocity * 3.6);
      hud.textContent = `속도: ${speedKmh} km/h`;

      // 조작 적용
      applyControls();

      // 카메라 위치 업데이트
      if (followCamera) {
        const offsetBack = new THREE.Vector3(0, 5, -15);
        const offsetUp = new THREE.Vector3(0, 3, 0);
        const carDir = new THREE.Vector3(0, 0, 1).applyQuaternion(carModel.quaternion);
        const carPos = carModel.position.clone();
        const camPos = carPos.clone().add(carDir.clone().multiplyScalar(-15)).add(offsetUp);
        camera.position.lerp(camPos, 0.2);
        const lookPos = carPos.clone().add(carDir.clone().multiplyScalar(8));
        camera.lookAt(lookPos);
      } else {
        // 자유 시점은 마우스 드래그로 조정됨
        const target = carModel.position.clone();
        const radius = 25;
        const camX = radius * Math.cos(yaw) * Math.cos(pitch);
        const camY = radius * Math.sin(pitch) + 5;
        const camZ = radius * Math.sin(yaw) * Math.cos(pitch);
        camera.position.set(target.x + camX, target.y + camY, target.z + camZ);
        camera.lookAt(target);
      }

      // 타이머 업데이트 (게임 시작 시 바로 시작)
      elapsedTime = (performance.now() - startTime) / 1000;
      timerDisplay.textContent = `타이머: ${elapsedTime.toFixed(2)} s`;

      renderer.render(scene, camera);
    }

    animate();

  </script>
</body>
</html>
