<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>3D Car Driving Game</title>

  <style>
    *{box-sizing:border-box}
    body{
      margin:0;overflow:hidden;
      background:#000;color:#fff;font-family:Arial,Helvetica,sans-serif
    }
    #rotateWarning{
      position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);
      background:rgba(0,0,0,.8);padding:20px;border-radius:10px;display:none;z-index:99
    }
    #buttons{
      position:fixed;bottom:20px;width:100%;display:flex;justify-content:space-between;
      padding:0 20px;z-index:10;pointer-events:none /* 버튼 영역 깜빡임 방지 */
    }
    #leftButtons,#rightButtons{display:flex;gap:10px}
    button{
      padding:14px 20px;font-size:16px;border:none;border-radius:12px;
      background:#4f9eff;color:#fff;font-weight:bold;pointer-events:auto
    }
    #speedometer,#driftIndicator{
      position:fixed;left:50%;transform:translateX(-50%);
      background:rgba(0,0,0,.6);padding:8px 20px;border-radius:10px;
      font-size:18px;font-weight:bold;text-align:center
    }
    #speedometer{bottom:80px}
    #driftIndicator{bottom:120px;opacity:0;transition:opacity .2s}
  </style>
</head>
<body>
  <div id="rotateWarning">가로 모드로 전환해주세요</div>

  <div id="driftIndicator">🔥 드리프트!</div>
  <div id="speedometer">속도: 0 km/h</div>

  <div id="buttons">
    <div id="leftButtons">
      <button id="leftBtn">◀ 좌</button>
      <button id="rightBtn">우 ▶</button>
    </div>
    <div id="rightButtons">
      <button id="accelBtn">엑셀</button>
      <button id="brakeBtn">브레이크</button>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
  <script>
    /* ───────────────── 기기 방향 경고 ───────────────── */
    const rotateWarning = document.getElementById("rotateWarning");
    function checkOrientation(){
      rotateWarning.style.display = (window.innerHeight>window.innerWidth)?"block":"none";
    }
    window.addEventListener("resize",checkOrientation);
    window.addEventListener("orientationchange",checkOrientation);
    checkOrientation();

    /* ───────────────── 전역 변수 ───────────────── */
    let scene,camera,renderer,car;
    let velocity = 0, maxSpeed = 200;
    let steerAngle = 0, steerSpeed = 0.03, steerDecay = 0.006;
    let heading = 0;                 // 실제 진행 방향 (미끄러질 때 차체 방향과 달라짐)
    let drifting = false;
    const driftThreshold = 0.18;     // 핸들 꺾임 한계
    const speedThreshold = 40;       // 미끄러지기 시작할 최소 속도
    const speedDisplay = document.getElementById("speedometer");
    const driftDisplay = document.getElementById("driftIndicator");

    init();
    animate();

    /* ───────────────── 초기화 ───────────────── */
    function init(){
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);

      camera = new THREE.PerspectiveCamera(60,window.innerWidth/window.innerHeight,0.1,1000);
      camera.position.set(0,5,-10);

      renderer = new THREE.WebGLRenderer({antialias:true});
      renderer.setSize(window.innerWidth,window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // 바닥
      const floorGeo = new THREE.PlaneGeometry(1000,1000);
      const floorMat = new THREE.MeshStandardMaterial({color:0x222222});
      const floor = new THREE.Mesh(floorGeo,floorMat);
      floor.rotation.x = -Math.PI/2;
      scene.add(floor);

      // 조명
      scene.add(new THREE.DirectionalLight(0xffffff,1).position.set(10,20,10));
      scene.add(new THREE.AmbientLight(0xffffff,0.5));

      // 자동차(박스)
      const carGeo = new THREE.BoxGeometry(2,1,4);
      const carMat = new THREE.MeshStandardMaterial({color:0xff3333});
      car = new THREE.Mesh(carGeo,carMat);
      car.position.y = 0.5;
      scene.add(car);

      window.addEventListener("resize",()=>{
        camera.aspect = window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth,window.innerHeight);
      });

      setupControls();
    }

    /* ───────────────── 버튼 입력 처리 ───────────────── */
    function setupControls(){
      let left=false,right=false,accel=false,brake=false;

      function bind(id,setter){
        const btn=document.getElementById(id);
        btn.addEventListener("mousedown",()=>setter(true));
        btn.addEventListener("mouseup",()=>setter(false));
        btn.addEventListener("mouseleave",()=>setter(false));
        btn.addEventListener("touchstart",e=>{e.preventDefault();setter(true)});
        btn.addEventListener("touchend",()=>setter(false));
      }
      bind("leftBtn",v=>left=v);
      bind("rightBtn",v=>right=v);
      bind("accelBtn",v=>accel=v);
      bind("brakeBtn",v=>brake=v);

      /* 입력 상태를 일정 주기로 업데이트 */
      setInterval(()=>{
        /* 조향 */
        if(left) steerAngle = Math.min(steerAngle + steerSpeed, 0.35);
        else if(right) steerAngle = Math.max(steerAngle - steerSpeed, -0.35);
        else{
          // 자연 복귀
          if(steerAngle>0) steerAngle = Math.max(steerAngle - steerDecay, 0);
          else if(steerAngle<0) steerAngle = Math.min(steerAngle + steerDecay, 0);
        }

        /* 가속·제동 */
        if(accel) velocity = Math.min(velocity + 1.2, maxSpeed);
        else if(brake) velocity = Math.max(velocity - 4, 0);
        else velocity = Math.max(velocity - 0.6, 0);

        /* 드리프트 판정: 속도 + 핸들 + (브레이크 중엔 쉽게) */
        drifting = (Math.abs(steerAngle) > driftThreshold && velocity > speedThreshold) || (brake && velocity>20 && Math.abs(steerAngle)>0.05);
        driftDisplay.style.opacity = drifting ? 1 : 0;
      },30);
    }

    /* ───────────────── 메인 루프 ───────────────── */
    function animate(){
      requestAnimationFrame(animate);

      /* 차체(시각적인 것)는 곧바로 조향 각도를 반영 */
      car.rotation.y += steerAngle;

      /* 진행 방향(heading)은 그립(Grip)값에 따라 차체 방향으로 서서히 수렴
         드리프트 시 그립을 줄여 미끄러짐 효과 */
      const grip = drifting ? 0.05 : 0.18;
      heading = lerpAngle(heading, car.rotation.y, grip);

      const moveZ = velocity * 0.02;
      car.position.x += Math.sin(heading) * moveZ;
      car.position.z += Math.cos(heading) * moveZ;

      /* 카메라 */
      const cameraOffset = new THREE.Vector3(0,4,-10).applyMatrix4(car.matrixWorld);
      camera.position.lerp(cameraOffset,0.08);
      camera.lookAt(car.position);

      /* UI */
      speedDisplay.textContent = `속도: ${Math.floor(velocity)} km/h`;

      renderer.render(scene,camera);
    }

    /* ───────────────── 보조 함수 ───────────────── */
    function lerpAngle(a,b,t){
      const diff = ((b - a + Math.PI) % (Math.PI*2)) - Math.PI;
      return a + diff*t;
    }
  </script>
</body>
</html>
