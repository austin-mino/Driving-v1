<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>3D driving</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #121212;
      font-family: 'Segoe UI', Tahoma, Verdana, sans-serif;
      color: #fff;
      user-select: none;
    }
    #rotateWarning {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.85);
      padding: 25px 40px;
      border-radius: 15px;
      font-size: 1.3rem;
      font-weight: bold;
      z-index: 1000;
      display: none;
    }
    #hud, #gearDisplay, #timerDisplay {
      position: fixed;
      background: rgba(0, 0, 0, 0.7);
      padding: 12px 18px;
      border-radius: 10px;
      font-weight: 700;
      font-size: 18px;
      user-select: none;
      z-index: 100;
    }
    #hud { top: 20px; left: 20px; }
    #gearDisplay { top: 10px; right: 20px; }
    #timerDisplay { top: 60px; left: 20px; }
    #gearControls {
      position: fixed;
      top: 50px;
      right: 20px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      z-index: 100;
    }
    #controlsLeft, #driveControls {
      position: fixed;
      bottom: 20px;
      display: flex;
      gap: 15px;
      z-index: 100;
      user-select: none;
    }
    #controlsLeft { left: 20px; }
    #driveControls { right: 20px; }
    button.controlBtn {
      padding: 14px 20px;
      border-radius: 12px;
      border: none;
      background: #0078d7;
      color: #fff;
      font-weight: 700;
      font-size: 16px;
      cursor: pointer;
      touch-action: manipulation;
      transition: background-color 0.2s, color 0.2s;
    }
    button.controlBtn:active {
      background: #005a9e;
    }
    @media (max-width: 600px) {
      button.controlBtn {
        padding: 18px 22px;
        font-size: 20px;
      }
    }
  </style>
</head>
<body>
  <div id="rotateWarning">가로 모드로 전환해주세요</div>
  <div id="hud">속도: 0 km/h</div>
  <div id="timerDisplay">타이머: 0.00 s</div>
  <div id="gearDisplay">기어: P</div>

  <!-- 좌/우 스티어링 -->
  <div id="controlsLeft">
    <button id="btnLeft" class="controlBtn">◀ 좌</button>
    <button id="btnRight" class="controlBtn">우 ▶</button>
  </div>
  <!-- 엑셀·브레이크 -->
  <div id="driveControls">
    <button id="btnAccel" class="controlBtn">엑셀</button>
    <button id="btnBrake" class="controlBtn">브레이크</button>
  </div>

  <!-- 기어 선택 -->
  <div id="gearControls">
    <button id="gearP" class="controlBtn">P</button>
    <button id="gearR" class="controlBtn">R</button>
    <button id="gearN" class="controlBtn">N</button>
    <button id="gearD" class="controlBtn">D</button>
    <button id="btnReset" class="controlBtn" style="margin-top: 20px;">차량 리셋</button>
  </div>

  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js';
    import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js';

    // 1. renderer 선언 및 초기화 (최상단에서 딱 한번)
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // 2. renderer.domElement 이벤트 등록 (카메라 마우스 드래그)
    let isDragging = false;
    let previousMousePosition = { x: 0, y: 0 };
    let yaw = 0;
    let pitch = 0.15; // 약간 위를 보는 초기값
    const sensitivity = 0.005;

    renderer.domElement.addEventListener('mousedown', (event) => {
      if (event.button === 0) {
        isDragging = true;
        previousMousePosition.x = event.clientX;
        previousMousePosition.y = event.clientY;
      }
    });
    renderer.domElement.addEventListener('mouseup', (event) => {
      if (event.button === 0) {
        isDragging = false;
      }
    });
    renderer.domElement.addEventListener('mousemove', (event) => {
      if (!isDragging) return;

      const deltaMove = {
        x: event.clientX - previousMousePosition.x,
        y: event.clientY - previousMousePosition.y
      };

      yaw -= deltaMove.x * sensitivity;
      pitch -= deltaMove.y * sensitivity;

      const pitchLimit = Math.PI / 3;
      pitch = Math.max(-pitchLimit, Math.min(pitchLimit, pitch));

      previousMousePosition.x = event.clientX;
      previousMousePosition.y = event.clientY;
    });

    // 가로모드 체크
    const rotateWarning = document.getElementById('rotateWarning');
    function checkOrientation() {
      rotateWarning.style.display = window.innerHeight > window.innerWidth ? 'block' : 'none';
    }
    window.addEventListener('resize', checkOrientation);
    window.addEventListener('orientationchange', checkOrientation);
    checkOrientation();

    // Three.js 기본 설정
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x222222);
    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.05, 5000);
    camera.position.set(0, 5, 15);
    camera.lookAt(0, 0, 0);

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // ───────────────────────────────────────────────
    // 1. 물리 엔진 월드 설정
    const world = new CANNON.World({ gravity: new CANNON.Vec3(0, -9.82, 0) });
    world.broadphase = new CANNON.SAPBroadphase(world);
    world.defaultContactMaterial.friction = 0.6;

    // 2. 지면 생성
    const groundBody = new CANNON.Body({ mass: 0 });
    groundBody.addShape(new CANNON.Plane());
    groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
    world.addBody(groundBody);

    // 3. 트랙 타원 파라미터
    const trackA = 500;  // x 방향 반지름
    const trackB = 60;   // z 방향 반지름
    const trackWidth = 60;
    const numSegments = 400; // 트랙 구성 정밀도

    // 4. 바리어 생성
    const barrierHeight = 1;
    const barrierThickness = 1;
    const barrierLength = 25;
    const barrierMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
    const barrierMeshes = [];

    for (let i = 0; i < numSegments; i++) {
      const angle = (i / numSegments) * 2 * Math.PI;

      // 중앙 타원 경로 좌표
      const cx = Math.cos(angle);
      const sz = Math.sin(angle);

      const innerX = (trackA - trackWidth / 2) * cx;
      const innerZ = (trackB - trackWidth / 2) * sz;

      const outerX = (trackA + trackWidth / 2) * cx;
      const outerZ = (trackB + trackWidth / 2) * sz;

      // 회전각: 접선 방향을 따라 회전
      const rotationY = -Math.atan2(
        (trackB * Math.cos(angle)),
        (-trackA * Math.sin(angle))
      );

      // 안쪽 바리어
      {
        const barrierShape = new CANNON.Box(new CANNON.Vec3(barrierLength / 2, barrierHeight / 2, barrierThickness / 2));
        const barrierBody = new CANNON.Body({ mass: 0 });
        barrierBody.addShape(barrierShape);
        barrierBody.position.set(innerX, barrierHeight / 3, innerZ);
        barrierBody.quaternion.setFromEuler(0, rotationY, 0);
        world.addBody(barrierBody);

        const barrierGeom = new THREE.BoxGeometry(barrierLength, barrierHeight, barrierThickness);
        const barrierMesh = new THREE.Mesh(barrierGeom, barrierMat);
        barrierMesh.position.copy(barrierBody.position);
        barrierMesh.quaternion.copy(barrierBody.quaternion);
        scene.add(barrierMesh);
        barrierMeshes.push(barrierMesh);
      }

      // 바깥쪽 바리어
      {
        const barrierShape = new CANNON.Box(new CANNON.Vec3(barrierLength / 2, barrierHeight / 2, barrierThickness / 2));
        const barrierBody = new CANNON.Body({ mass: 0 });
        barrierBody.addShape(barrierShape);
        barrierBody.position.set(outerX, barrierHeight / 3, outerZ);
        barrierBody.quaternion.setFromEuler(0, rotationY, 0);
        world.addBody(barrierBody);

        const barrierGeom = new THREE.BoxGeometry(barrierLength, barrierHeight, barrierThickness);
        const barrierMesh = new THREE.Mesh(barrierGeom, barrierMat);
        barrierMesh.position.copy(barrierBody.position);
        barrierMesh.quaternion.copy(barrierBody.quaternion);
        scene.add(barrierMesh);
        barrierMeshes.push(barrierMesh);
      }
    }

    // 트랙 메쉬 생성
    const trackShape = new THREE.Shape();
    for (let i = 0; i <= numSegments; i++) {
      const angle = (i / numSegments) * 2 * Math.PI;
      const x = trackA * Math.cos(angle);
      const z = trackB * Math.sin(angle);
      if (i === 0) {
        trackShape.moveTo(x, z);
      } else {
        trackShape.lineTo(x, z);
      }
    }
    const extrudeSettings = { depth:0.1, bevelEnabled: false };
    const geometry = new THREE.ExtrudeGeometry(trackShape, extrudeSettings);
    const material = new THREE.MeshStandardMaterial({ color: 0x222222 });
    const mesh = new THREE.Mesh(geometry, material);
    mesh.rotation.x = -Math.PI / 2;
    mesh.position.y = -trackWidth / 2;  // ← 이 줄 유지
    scene.add(mesh);

    // 자동차 차체 물리 (박스)
    const chassisShape = new CANNON.Box(new CANNON.Vec3(1.5, 0.5, 3));
    const chassisBody = new CANNON.Body({ mass: 110 });
    chassisBody.addShape(chassisShape);
    chassisBody.position.set(500, 0.5, 0); // 땅 바로 위
    chassisBody.angularDamping = 0.5;
    chassisBody.linearDamping = 0.0;
    world.addBody(chassisBody);

    // 자동차 시각 모델 (둥근 차체)
    const carModel = createGrandeurIGCarDetailed();
    scene.add(carModel);

    // 휠 생성 함수
    function createWheel() {
      const wheelGroup = new THREE.Group();

      const tireGeo = new THREE.CylinderGeometry(0.5, 0.5, 0.4, 24);
      const tireMat = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.7, roughness: 0.4 });
      const tireMesh = new THREE.Mesh(tireGeo, tireMat);
      tireMesh.rotation.z = Math.PI / 2;
      wheelGroup.add(tireMesh);

      const rimMat = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 1.0, roughness: 0.3 });
      const rimGeo = new THREE.TorusGeometry(0.5, 0.15, 16, 100);
      const rimMesh = new THREE.Mesh(rimGeo, rimMat);
      rimMesh.rotation.z = Math.PI / 2;
      wheelGroup.add(rimMesh);

      return wheelGroup;
    }

    // RaycastVehicle 세팅
    const vehicle = new CANNON.RaycastVehicle({
      chassisBody,
      indexRightAxis: 0, // x축 오른쪽
      indexUpAxis: 1,    // y축 위쪽
      indexForwardAxis: 2, // z축 앞쪽
    });

    // 휠 옵션
    const wheelOptions = {
      radius: 1.5,
      directionLocal: new CANNON.Vec3(0, -1, 0),
      suspensionStiffness: 45,
      suspensionRestLength: 0.4,
      frictionSlip: 5,
      dampingRelaxation: 2.3,
      dampingCompression: 4.4,
      maxSuspensionForce: 1e4,
      rollInfluence: 0.02,
      axleLocal: new CANNON.Vec3(1, 0, 0),
      maxSuspensionTravel: 0.3,
      useCustomSlidingRotationalSpeed: true,
      customSlidingRotationalSpeed: -30,
    };

    // 휠 위치 (x,z)
    const wheelPositions = [
      [-2.3, -5], // 왼쪽 앞
      [2.3, -5],  // 오른쪽 앞
      [-2.3, 5],  // 왼쪽 뒤
      [2.3, 5],   // 오른쪽 뒤
    ];

    // 휠 추가 및 시각 휠 그룹 생성
    const wheelHolders = [];
    for (let i = 0; i < wheelPositions.length; i++) {
      const [x, z] = wheelPositions[i];
      vehicle.addWheel({
        ...wheelOptions,
        chassisConnectionPointLocal: new CANNON.Vec3(x, 0, z),
      });
      const wheelVisual = createWheel();
      scene.add(wheelVisual);
      wheelHolders.push(wheelVisual);
    }

    vehicle.addToWorld(world);

    // 조명
    scene.add(new THREE.AmbientLight(0xffffff, 1));
    const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
    dirLight.position.set(10, 20, 10);
    scene.add(dirLight);

    // 입력 상태
    const input = { left: false, right: false, accel: false, brake: false };

    // DOM 요소 바인딩
    const btnLeft = document.getElementById('btnLeft'),
          btnRight = document.getElementById('btnRight'),
          btnAccel = document.getElementById('btnAccel'),
          btnBrake = document.getElementById('btnBrake'),
          gearDisplay = document.getElementById('gearDisplay'),
          gearButtons = [...document.querySelectorAll('#gearControls button')],
          hud = document.getElementById('hud'),
          timerDisplay = document.getElementById('timerDisplay');

    // 초기 기어 상태
    let gearState = 'P';

    // 키보드 입력 처리
    window.addEventListener('keydown', e => {
      switch(e.key.toLowerCase()) {
        case 'arrowleft':
        case 'a': input.left = true; break;
        case 'arrowright':
        case 'd': input.right = true; break;
        case 'arrowup':
        case 'w': input.accel = true; break;
        case 'arrowdown':
        case 's': input.brake = true; break;
        case '1': setGear('P'); break;
        case '2': setGear('R'); break;
        case '3': setGear('N'); break;
        case '4': setGear('D'); break;
      }
    });

    window.addEventListener('keyup', e => {
      switch(e.key.toLowerCase()) {
        case 'arrowleft':
        case 'a': input.left = false; break;
        case 'arrowright':
        case 'd': input.right = false; break;
        case 'arrowup':
        case 'w': input.accel = false; break;
        case 'arrowdown':
        case 's': input.brake = false; break;
      }
    });

    // 모바일 버튼 바인딩 함수
    function bindButton(button, prop) {
      const setTrue = e => { e.preventDefault(); input[prop] = true; };
      const setFalse = e => { e.preventDefault(); input[prop] = false; };
      button.addEventListener('mousedown', setTrue);
      button.addEventListener('touchstart', setTrue);
      button.addEventListener('mouseup', setFalse);
      button.addEventListener('touchend', setFalse);
      button.addEventListener('touchcancel', setFalse);
      button.addEventListener('mouseout', setFalse);
    }

    bindButton(btnLeft, 'left');
    bindButton(btnRight, 'right');
    bindButton(btnAccel, 'accel');
    bindButton(btnBrake, 'brake');

    // 기어 버튼 이벤트
    document.getElementById('gearP').onclick = () => setGear('P');
    document.getElementById('gearR').onclick = () => setGear('R');
    document.getElementById('gearN').onclick = () => setGear('N');
    document.getElementById('gearD').onclick = () => setGear('D');

    // 리셋 버튼 이벤트
    document.getElementById('btnReset').onclick = () => {
      resetCar();
    };

    function setGear(g) {
      gearState = g;
      updateGearDisplay();

      if (gearState === 'P') {
        vehicle.setBrake(1, 0);
        vehicle.setBrake(1, 1);
        vehicle.setBrake(1, 2);
        vehicle.setBrake(1, 3);
      } else {
        vehicle.setBrake(0, 0);
        vehicle.setBrake(0, 1);
        vehicle.setBrake(0, 2);
        vehicle.setBrake(0, 3);
      }

      // 타이머 리셋
      if (gearState === 'D') {
        if (startTime === null) startTime = performance.now();
      } else {
        startTime = null;
        elapsedTime = 0;
      }
    }

    function updateGearDisplay() {
      gearDisplay.textContent = `기어: ${gearState}`;
      const colorMap = { P: '#00ffff', R: '#ff5555', N: '#ffff55', D: '#55ff55' };
      gearDisplay.style.color = colorMap[gearState] || '#fff';
    }

    // 타이머 변수
    let startTime = null;
    let elapsedTime = 0;

    function updateTimer() {
      if (startTime === null) {
        timerDisplay.textContent = `타이머: 0.00 s`;
        return;
      }
      elapsedTime = (performance.now() - startTime) / 1000;
      timerDisplay.textContent = `타이머: ${elapsedTime.toFixed(2)} s`;
    }

    // 초기 기어 표시
    updateGearDisplay();

    // 차량 리셋 함수
    function resetCar() {
      chassisBody.position.set(500, 0.5, 0);
      chassisBody.velocity.set(0, 0, 0);
      chassisBody.angularVelocity.set(0, 0, 0);
      chassisBody.quaternion.set(0, 0, 0, 1);

      for (let i = 0; i < vehicle.wheelInfos.length; i++) {
        vehicle.wheelInfos[i].rotation = 0;
        vehicle.wheelInfos[i].deltaRotation = 0;
      }

      startTime = null;
      elapsedTime = 0;
    }

    // 자동차 조작
    function updateVehicleControls() {
      const maxSteerVal = 0.6;
      const maxForce = 2000;
      const brakeForce = 100;

      // 좌우 조향
      if (input.left) {
        vehicle.setSteeringValue(maxSteerVal, 0);
        vehicle.setSteeringValue(maxSteerVal, 1);
      } else if (input.right) {
        vehicle.setSteeringValue(-maxSteerVal, 0);
        vehicle.setSteeringValue(-maxSteerVal, 1);
      } else {
        vehicle.setSteeringValue(0, 0);
        vehicle.setSteeringValue(0, 1);
      }

      // 엑셀, 브레이크 및 기어에 따른 토크
      if (gearState === 'D') {
        if (input.accel) {
          vehicle.applyEngineForce(-maxForce, 2);
          vehicle.applyEngineForce(-maxForce, 3);
        } else if (input.brake) {
          vehicle.setBrake(brakeForce, 2);
          vehicle.setBrake(brakeForce, 3);
          vehicle.applyEngineForce(0, 2);
          vehicle.applyEngineForce(0, 3);
        } else {
          vehicle.applyEngineForce(0, 2);
          vehicle.applyEngineForce(0, 3);
          vehicle.setBrake(0, 2);
          vehicle.setBrake(0, 3);
        }
      } else if (gearState === 'R') {
        if (input.accel) {
          vehicle.applyEngineForce(maxForce, 2);
          vehicle.applyEngineForce(maxForce, 3);
        } else if (input.brake) {
          vehicle.setBrake(brakeForce, 2);
          vehicle.setBrake(brakeForce, 3);
          vehicle.applyEngineForce(0, 2);
          vehicle.applyEngineForce(0, 3);
        } else {
          vehicle.applyEngineForce(0, 2);
          vehicle.applyEngineForce(0, 3);
          vehicle.setBrake(0, 2);
          vehicle.setBrake(0, 3);
        }
      } else {
        // P, N 기어는 무조건 정지
        vehicle.setBrake(brakeForce * 5, 0);
        vehicle.setBrake(brakeForce * 5, 1);
        vehicle.setBrake(brakeForce * 5, 2);
        vehicle.setBrake(brakeForce * 5, 3);
        vehicle.applyEngineForce(0, 0);
        vehicle.applyEngineForce(0, 1);
        vehicle.applyEngineForce(0, 2);
        vehicle.applyEngineForce(0, 3);
      }
    }

    // 속도 계산 (km/h)
    function getSpeedKmH() {
      return chassisBody.velocity.length() * 3.6;
    }

    // 카메라 업데이트
    function updateCamera() {
      // 자동차 위치 기준으로 뒤에서 바라보는 위치 계산
      const carPos = new THREE.Vector3();
      carPos.copy(carModel.position);

      // 카메라 위치 offset
      const offset = new THREE.Vector3(0, 5, 15);

      // yaw, pitch 회전 행렬
      const quaternion = new THREE.Quaternion()
        .setFromEuler(new THREE.Euler(pitch, yaw, 0, 'YXZ'));

      offset.applyQuaternion(quaternion);

      camera.position.copy(carPos).add(offset);
      camera.lookAt(carPos);
    }

    // 애니메이션 루프
    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);

      const delta = clock.getDelta();

      updateVehicleControls();

      world.step(1 / 60, delta, 3);

      // 차량 모델 위치 동기화
      carModel.position.copy(chassisBody.position);
      carModel.quaternion.copy(chassisBody.quaternion);

      // 휠 위치 동기화
      for (let i = 0; i < vehicle.wheelInfos.length; i++) {
        vehicle.updateWheelTransform(i);
        const t = vehicle.wheelInfos[i].worldTransform;
        wheelHolders[i].position.copy(t.position);
        wheelHolders[i].quaternion.copy(t.quaternion);
      }

      hud.textContent = `속도: ${getSpeedKmH().toFixed(1)} km/h`;
      updateTimer();
      updateCamera();

      renderer.render(scene, camera);
    }

    animate();

    // --------- 함수: 그랜저 IG 차체 모델 함수 --------------
    // 실제 모양과 최대한 비슷하게 간단하게 구성한 예시
    function createGrandeurIGCarDetailed() {
      const group = new THREE.Group();

      // 차체 메인
      const bodyMat = new THREE.MeshStandardMaterial({ color: 0xa9a9a9, metalness: 0.7, roughness: 0.3 });
      const bodyGeo = new THREE.BoxGeometry(3, 1.2, 7);
      const bodyMesh = new THREE.Mesh(bodyGeo, bodyMat);
      bodyMesh.position.y = 0.6;
      bodyMesh.castShadow = true;
      group.add(bodyMesh);

      // 차체 둥근 모서리 (간단 처리)
      const edgeMat = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.5, roughness: 0.5 });
      const edgeGeo = new THREE.SphereGeometry(0.6, 12, 12);

      const edgePositions = [
        [1.5, 0.6, 3.5],
        [-1.5, 0.6, 3.5],
        [1.5, 0.6, -3.5],
        [-1.5, 0.6, -3.5],
      ];

      edgePositions.forEach(pos => {
        const sphere = new THREE.Mesh(edgeGeo, edgeMat);
        sphere.position.set(...pos);
        group.add(sphere);
      });

      // 창문 (간단한 사각형)
      const windowMat = new THREE.MeshStandardMaterial({ color: 0x333366, metalness: 0.2, roughness: 0.4, opacity: 0.5, transparent: true });
      const windowGeo = new THREE.BoxGeometry(2.4, 0.8, 4.5);
      const windowMesh = new THREE.Mesh(windowGeo, windowMat);
      windowMesh.position.set(0, 1.2, 0);
      group.add(windowMesh);

      // 라이트 (앞)
      const lightMat = new THREE.MeshStandardMaterial({ color: 0xfff4cc, emissive: 0xfff4cc, emissiveIntensity: 1 });
      const lightGeo = new THREE.BoxGeometry(0.4, 0.3, 0.15);
      const lightFrontL = new THREE.Mesh(lightGeo, lightMat);
      lightFrontL.position.set(-1, 0.6, 3.6);
      group.add(lightFrontL);
      const lightFrontR = lightFrontL.clone();
      lightFrontR.position.x = 1;
      group.add(lightFrontR);

      // 전체 크기 조정
      group.scale.set(1, 1, 1);

      return group;
    }
  </script>
</body>
</html>
