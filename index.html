<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>실제 자동차 물리엔진 게임 (모바일 터치 기어 변속 포함)</title>
<style>
  body { margin: 0; overflow: hidden; background: #000; color: #fff; font-family: Arial, sans-serif; }
  #speedBox {
    position: fixed; top: 10px; left: 10px; background: rgba(0,0,0,0.6); padding: 10px 20px;
    border-radius: 10px; font-weight: bold; font-size: 18px; z-index: 10;
  }
  #gearBox {
    position: fixed; top: 10px; right: 10px; background: rgba(0,0,0,0.6);
    padding: 10px; border-radius: 10px; display: flex; flex-direction: column; gap: 8px; z-index: 10;
  }
  .gearButton {
    background: #4f9eff; border: none; border-radius: 8px; padding: 12px 16px;
    font-weight: bold; font-size: 18px; color: #fff; user-select: none;
    touch-action: manipulation;
  }
  .gearButton.active {
    background: #ff9b00;
  }
  #buttonsLeft {
    position: fixed; bottom: 20px; left: 20px; display: flex; gap: 12px; z-index: 10;
  }
  #buttonsRight {
    position: fixed; bottom: 20px; right: 20px; display: flex; gap: 12px; z-index: 10;
  }
  button.controlBtn {
    padding: 14px 20px; font-size: 16px; border: none; border-radius: 12px;
    background: #4f9eff; color: #fff; font-weight: bold; user-select: none;
    touch-action: manipulation;
  }
</style>
</head>
<body>

<div id="speedBox">속도: 0 km/h</div>
<div id="gearBox">
  <button class="gearButton active" data-gear="P">P</button>
  <button class="gearButton" data-gear="R">R</button>
  <button class="gearButton" data-gear="N">N</button>
  <button class="gearButton" data-gear="D">D</button>
</div>

<div id="buttonsLeft">
  <button id="leftBtn" class="controlBtn">◀ 좌</button>
  <button id="rightBtn" class="controlBtn">우 ▶</button>
</div>
<div id="buttonsRight">
  <button id="accelBtn" class="controlBtn">엑셀</button>
  <button id="brakeBtn" class="controlBtn">브레이크</button>
</div>

<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js';
import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js';

const speedBox = document.getElementById('speedBox');
const gearButtons = document.querySelectorAll('.gearButton');

let currentGear = 'P';
gearButtons.forEach(btn => {
  btn.addEventListener('click', () => {
    currentGear = btn.dataset.gear;
    updateGearButtons();
  });
});
function updateGearButtons(){
  gearButtons.forEach(btn => {
    btn.classList.toggle('active', btn.dataset.gear === currentGear);
  });
}

/* THREE.js 세팅 */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0, 5, -10);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 0.6));
const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
dirLight.position.set(5, 10, -5);
scene.add(dirLight);

/* CANNON 물리엔진 세팅 */
const world = new CANNON.World({
  gravity: new CANNON.Vec3(0, -9.82, 0)
});
world.broadphase = new CANNON.SAPBroadphase(world);
world.defaultContactMaterial.friction = 0.6;

/* 바닥 */
const groundBody = new CANNON.Body({
  mass: 0,
  shape: new CANNON.Plane()
});
groundBody.quaternion.setFromEuler(-Math.PI/2, 0, 0);
world.addBody(groundBody);

const groundMesh = new THREE.Mesh(
  new THREE.PlaneGeometry(500, 500),
  new THREE.MeshStandardMaterial({color: 0x333333})
);
groundMesh.rotation.x = -Math.PI/2;
scene.add(groundMesh);

/* 자동차 차체 생성 */
const chassisShape = new CANNON.Box(new CANNON.Vec3(1.6, 0.5, 3));
const chassisBody = new CANNON.Body({mass: 150});
chassisBody.addShape(chassisShape);
chassisBody.position.set(0, 1, 0);
world.addBody(chassisBody);

/* 자동차 시각화 - 차체 */
const chassisMesh = new THREE.Group();

// 실제 자동차처럼 생긴 차체 디자인 (본체 + 지붕 + 창문 + 디테일)
const bodyMaterial = new THREE.MeshStandardMaterial({color: 0xff0000, metalness: 0.7, roughness: 0.3});
const bodyGeometry = new THREE.BoxGeometry(3.2, 1, 6);
const bodyMesh = new THREE.Mesh(bodyGeometry, bodyMaterial);
bodyMesh.position.y = 0.5;
chassisMesh.add(bodyMesh);

// 지붕
const roofGeometry = new THREE.BoxGeometry(2.8, 0.6, 3);
const roofMaterial = new THREE.MeshStandardMaterial({color: 0xaa2222, metalness: 0.5, roughness: 0.4});
const roofMesh = new THREE.Mesh(roofGeometry, roofMaterial);
roofMesh.position.set(0, 1.0, -0.5);
chassisMesh.add(roofMesh);

// 창문
const windowMaterial = new THREE.MeshStandardMaterial({color: 0x5555aa, opacity: 0.5, transparent: true, roughness: 0.1});
const frontWindowGeometry = new THREE.BoxGeometry(2.6, 0.5, 0.05);
const frontWindowMesh = new THREE.Mesh(frontWindowGeometry, windowMaterial);
frontWindowMesh.position.set(0, 1.0, -2.0);
chassisMesh.add(frontWindowMesh);

const rearWindowMesh = frontWindowMesh.clone();
rearWindowMesh.position.set(0, 1.0, 2.0);
chassisMesh.add(rearWindowMesh);

const leftWindowGeometry = new THREE.BoxGeometry(0.05, 0.5, 4);
const leftWindowMesh = new THREE.Mesh(leftWindowGeometry, windowMaterial);
leftWindowMesh.position.set(-1.6, 1.0, 0);
chassisMesh.add(leftWindowMesh);

const rightWindowMesh = leftWindowMesh.clone();
rightWindowMesh.position.set(1.6, 1.0, 0);
chassisMesh.add(rightWindowMesh);

// 바퀴 메시 - 실제 타이어 모양으로 원통형
const wheelMaterial = new THREE.MeshStandardMaterial({color: 0x222222, metalness: 0.8, roughness: 0.7});
const wheelGeometry = new THREE.CylinderGeometry(0.6, 0.6, 0.5, 32, 1, true);

const wheelMeshes = [];
function createWheelMesh() {
  const mesh = new THREE.Mesh(wheelGeometry, wheelMaterial);
  mesh.rotation.z = Math.PI / 2;
  return mesh;
}

// 앞 왼쪽 바퀴
const frontLeftWheelMesh = createWheelMesh();
chassisMesh.add(frontLeftWheelMesh);
// 앞 오른쪽 바퀴
const frontRightWheelMesh = createWheelMesh();
chassisMesh.add(frontRightWheelMesh);
// 뒤 왼쪽 바퀴
const rearLeftWheelMesh = createWheelMesh();
chassisMesh.add(rearLeftWheelMesh);
// 뒤 오른쪽 바퀴
const rearRightWheelMesh = createWheelMesh();
chassisMesh.add(rearRightWheelMesh);

scene.add(chassisMesh);

/* RaycastVehicle 세팅 */
const vehicle = new CANNON.RaycastVehicle({
  chassisBody: chassisBody,
  indexRightAxis: 0,   // x
  indexUpAxis: 1,      // y
  indexForwardAxis: 2  // z
});

const wheelOptions = {
  radius: 0.6,
  directionLocal: new CANNON.Vec3(0, -1, 0),
  suspensionStiffness: 30,
  suspensionRestLength: 0.3,
  axleLocal: new CANNON.Vec3(-1, 0, 0),
  frictionSlip: 4,
  dampingRelaxation: 2.3,
  dampingCompression: 4.4,
  maxSuspensionForce: 1e4,
  rollInfluence: 0.01,
  maxSuspensionTravel: 0.3,
  customSlidingRotationalSpeed: -30,
  useCustomSlidingRotationalSpeed: true
};

vehicle.addWheel({...wheelOptions, chassisConnectionPointLocal: new CANNON.Vec3(-1.2, 0, 2.3), isFrontWheel: true});
vehicle.addWheel({...wheelOptions, chassisConnectionPointLocal: new CANNON.Vec3(1.2, 0, 2.3), isFrontWheel: true});
vehicle.addWheel({...wheelOptions, chassisConnectionPointLocal: new CANNON.Vec3(-1.2, 0, -2.3), isFrontWheel: false});
vehicle.addWheel({...wheelOptions, chassisConnectionPointLocal: new CANNON.Vec3(1.2, 0, -2.3), isFrontWheel: false});

vehicle.addToWorld(world);

/* 바퀴 메시 배열 */
const wheelMeshesArray = [frontLeftWheelMesh, frontRightWheelMesh, rearLeftWheelMesh, rearRightWheelMesh];

/* 입력 상태 */
const inputState = {
  left: false,
  right: false,
  accel: false,
  brake: false
};

const maxSteerVal = Math.PI / 6; // ±30도
const maxForceForward = 3500;
const maxForceReverse = 1200;

let steeringValue = 0;
let engineForce = 0;
let brakeForce = 0;

/* 버튼 바인딩 */
function bindButton(id, key) {
  const btn = document.getElementById(id);
  btn.addEventListener('pointerdown', () => { inputState[key] = true; });
  btn.addEventListener('pointerup', () => { inputState[key] = false; });
  btn.addEventListener('pointerleave', () => { inputState[key] = false; });
  btn.addEventListener('touchstart', e => { e.preventDefault(); inputState[key] = true; }, {passive:false});
  btn.addEventListener('touchend', e => { e.preventDefault(); inputState[key] = false; }, {passive:false});
}

bindButton('leftBtn', 'left');
bindButton('rightBtn', 'right');
bindButton('accelBtn', 'accel');
bindButton('brakeBtn', 'brake');

/* 애니메이션 루프 */
let lastTime = performance.now();

function animate() {
  requestAnimationFrame(animate);
  const time = performance.now();
  const delta = (time - lastTime) / 1000;
  lastTime = time;

  // 조향값 업데이트
  if(inputState.left) steeringValue = Math.min(steeringValue + 0.03, maxSteerVal);
  else if(inputState.right) steeringValue = Math.max(steeringValue - 0.03, -maxSteerVal);
  else steeringValue *= 0.9;

  vehicle.setSteeringValue(steeringValue, 0);
  vehicle.setSteeringValue(steeringValue, 1);

  // 엔진 힘과 브레이크
  engineForce = 0;
  brakeForce = 0;

  if(currentGear === 'D'){
    if(inputState.accel) engineForce = maxForceForward;
    if(inputState.brake) brakeForce = 2000;
  } else if(currentGear === 'R'){
    if(inputState.accel) engineForce = -maxForceReverse;
    if(inputState.brake) brakeForce = 2000;
  } else if(currentGear === 'P'){
    brakeForce = 1e5; // 완전 고정
  } else if(currentGear === 'N'){
    if(inputState.brake) brakeForce = 2000;
  }

  vehicle.applyEngineForce(engineForce, 2);
  vehicle.applyEngineForce(engineForce, 3);

  for(let i=0; i<4; i++){
    vehicle.setBrake(brakeForce, i);
  }

  // 물리 세계 업데이트
  world.step(1/60, delta, 3);

  // 차체 메시 위치/회전 동기화
  chassisMesh.position.copy(chassisBody.position);
  chassisMesh.quaternion.copy(chassisBody.quaternion);

  // 바퀴 메시 위치/회전 동기화
  for(let i=0; i<vehicle.wheelInfos.length; i++){
    vehicle.updateWheelTransform(i);
    const t = vehicle.wheelInfos[i].worldTransform;
    wheelMeshesArray[i].position.copy(t.position);
    wheelMeshesArray[i].quaternion.copy(t.quaternion);
  }

  // 카메라: 자동차 뒤쪽에서 따라오기
  const carPos = chassisMesh.position.clone();
  const carQuat = chassisMesh.quaternion.clone();
  const forward = new THREE.Vector3(0, 0, 1).applyQuaternion(carQuat);
  const camPos = carPos.clone().add(forward.multiplyScalar(-10));
  camPos.y += 5;
  camera.position.lerp(camPos, 0.1);
  camera.lookAt(carPos);

  // 속도 표시 (km/h)
  const speedKmh = chassisBody.velocity.length() * 3.6;
  speedBox.textContent = `속도: ${speedKmh.toFixed(0)} km/h`;

  renderer.render(scene, camera);
}

animate();

</script>
</body>
</html>
