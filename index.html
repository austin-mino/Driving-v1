<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>3D driving</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #121212;
      font-family: 'Segoe UI', Tahoma, Verdana, sans-serif;
      color: #fff;
      user-select: none;
    }
    #rotateWarning {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.85);
      padding: 25px 40px;
      border-radius: 15px;
      font-size: 1.3rem;
      font-weight: bold;
      z-index: 1000;
      display: none;
    }
    #hud, #gearDisplay, #timerDisplay {
      position: fixed;
      background: rgba(0, 0, 0, 0.7);
      padding: 12px 18px;
      border-radius: 10px;
      font-weight: 700;
      font-size: 18px;
      user-select: none;
      z-index: 100;
    }
    #hud { top: 20px; left: 20px; }
    #gearDisplay { top: 10px; right: 20px; }
    #timerDisplay { top: 60px; left: 20px; }
    #gearControls {
      position: fixed;
      top: 50px;
      right: 20px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      z-index: 100;
    }
    #controlsLeft, #driveControls {
      position: fixed;
      bottom: 20px;
      display: flex;
      gap: 15px;
      z-index: 100;
      user-select: none;
    }
    #controlsLeft { left: 20px; }
    #driveControls { right: 20px; }
    button.controlBtn {
      padding: 14px 20px;
      border-radius: 12px;
      border: none;
      background: #0078d7;
      color: #fff;
      font-weight: 700;
      font-size: 16px;
      cursor: pointer;
      touch-action: manipulation;
      transition: background-color 0.2s, color 0.2s;
    }
    button.controlBtn:active {
      background: #005a9e;
    }
    @media (max-width: 600px) {
      button.controlBtn {
        padding: 18px 22px;
        font-size: 20px;
      }
    }
  </style>
</head>
<body>
  <div id="rotateWarning">가로 모드로 전환해주세요</div>
  <div id="hud">속도: 0 km/h</div>
  <div id="timerDisplay">타이머: 0.00 s</div>
  <div id="gearDisplay">기어: P</div>

  <!-- 좌/우 스티어링 -->
  <div id="controlsLeft">
    <button id="btnLeft" class="controlBtn">◀ 좌</button>
    <button id="btnRight" class="controlBtn">우 ▶</button>
  </div>
  <!-- 엑셀·브레이크 -->
  <div id="driveControls">
    <button id="btnAccel" class="controlBtn">엑셀</button>
    <button id="btnBrake" class="controlBtn">브레이크</button>
  <div id="reset">
    <!-- 기어 선택 아래에 추가 -->
    <button id="btnReset" class="controlBtn">차량 리셋</button>
  </div>
    <!-- 기어 선택 -->
  <div id="gearControls">
    <button id="gearP" class="controlBtn">P</button>
    <button id="gearR" class="controlBtn">R</button>
    <button id="gearN" class="controlBtn">N</button>
    <button id="gearD" class="controlBtn">D</button>
  </div>

  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js';
    import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js';

    // 가로모드 체크
    const rotateWarning = document.getElementById('rotateWarning');
    function checkOrientation() {
      rotateWarning.style.display = window.innerHeight > window.innerWidth ? 'block' : 'none';
    }
    window.addEventListener('resize', checkOrientation);
    window.addEventListener('orientationchange', checkOrientation);
    checkOrientation();

    // Three.js 기본 설정
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x222222);
    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.05, 5000);
    camera.position.set(0, 5, 15);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
document.getElementById('btnReset').addEventListener('click', resetCar);
window.addEventListener('keydown', e => {
  if (e.key.toLowerCase() === 'r') resetCar();
});

function resetCar() {
  // 위치는 그대로, 높이 약간 위로
  const pos = chassisBody.position;
  chassisBody.position.set(pos.x, pos.y + 1.5, pos.z);

  // 회전 초기화 (y축은 유지해서 방향은 그대로)
  const yRot = getYRotation(chassisBody.quaternion);
  chassisBody.quaternion.setFromEuler(0, yRot, 0);

  // 속도 초기화
  chassisBody.velocity.set(0, 0, 0);
  chassisBody.angularVelocity.set(0, 0, 0);
}

// 쿼터니언에서 y축 회전값 추출
function getYRotation(q) {
  const siny_cosp = 2 * (q.w * q.y + q.z * q.x);
  const cosy_cosp = 1 - 2 * (q.y * q.y + q.z * q.z);
  return Math.atan2(siny_cosp, cosy_cosp);
}
    // ───────────────────────────────────────────────
// 1. 월드 설정
const world = new CANNON.World({ gravity: new CANNON.Vec3(0, -9.82, 0) });
world.broadphase = new CANNON.SAPBroadphase(world);
world.defaultContactMaterial.friction = 0.6;

// 2. 지면 생성
const groundBody = new CANNON.Body({ mass: 0 });
groundBody.addShape(new CANNON.Plane());
groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
world.addBody(groundBody);

// 3. 트랙 타원 파라미터
const trackA = 500;  // x 방향 반지름
const trackB = 60;   // z 방향 반지름
const trackWidth = 60;
const numSegments = 400; // 트랙 구성 정밀도

// 4. 바리어 생성
const barrierHeight = 1;
const barrierThickness = 1;
const barrierLength = 25;

// Three.js 재질 재사용
const barrierMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
const barrierMeshes = [];

for (let i = 0; i < numSegments; i++) {
  const angle = (i / numSegments) * 2 * Math.PI;

  // 중앙 타원 경로 좌표
  const cx = Math.cos(angle);
  const sz = Math.sin(angle);

  const innerX = (trackA - trackWidth / 2) * cx;
  const innerZ = (trackB - trackWidth / 2) * sz;

  const outerX = (trackA + trackWidth / 2) * cx;
  const outerZ = (trackB + trackWidth / 2) * sz;

  // 회전각: 접선 방향을 따라 회전
  const rotationY = -Math.atan2(
    (trackB * Math.cos(angle)),
    (-trackA * Math.sin(angle))
  );

  // 왼쪽(안쪽) 바리어
  [innerX, innerZ].forEach((_, index) => {
    const isInner = index === 0;
    const x = isInner ? innerX : outerX;
    const z = isInner ? innerZ : outerZ;

    const barrierShape = new CANNON.Box(new CANNON.Vec3(barrierLength / 2, barrierHeight / 2, barrierThickness / 2));
    const barrierBody = new CANNON.Body({ mass: 0 });
    barrierBody.addShape(barrierShape);
    barrierBody.position.set(x, barrierHeight / 3, z);
    barrierBody.quaternion.setFromEuler(0, rotationY, 0);
    world.addBody(barrierBody);

    const barrierGeom = new THREE.BoxGeometry(barrierLength, barrierHeight, barrierThickness);
    const barrierMesh = new THREE.Mesh(barrierGeom, barrierMat);
    barrierMesh.position.copy(barrierBody.position);
    barrierMesh.quaternion.copy(barrierBody.quaternion);
    scene.add(barrierMesh);
    barrierMeshes.push(barrierMesh);
  });
}
    const trackShape = new THREE.Shape();
for (let i = 0; i <= numSegments; i++) {
  const angle = (i / numSegments) * 2 * Math.PI;
  const x = trackA * Math.cos(angle);
  const z = trackB * Math.sin(angle);
  if (i === 0) {
    trackShape.moveTo(x, z);
  } else {
    trackShape.lineTo(x, z);
  }
}
const extrudeSettings = { depth:0.1, bevelEnabled: false };
const geometry = new THREE.ExtrudeGeometry(trackShape, extrudeSettings);
const material = new THREE.MeshStandardMaterial({ color: 0x222222 });
const mesh = new THREE.Mesh(geometry, material);
mesh.rotation.x = -Math.PI / 2;
mesh.position.y = -trackWidth / 2;  // ← 이 줄 추가
scene.add(mesh);

    // 자동차 차체 물리 (박스)
    const chassisShape = new CANNON.Box(new CANNON.Vec3(1.5, 0.5, 3));
    const chassisBody = new CANNON.Body({ mass: 110 });
    chassisBody.addShape(chassisShape);
    chassisBody.position.set(500, 0.5, 0);
    chassisBody.angularDamping = 0.5;
    chassisBody.linearDamping = 0.0;
    world.addBody(chassisBody);
    const carMesh = createRoundedCarBody();
scene.add(carMesh);

    // 자동차 시각 모델 (둥근 차체)
  5, 0.35, 2.6]
  ]function createRoundedCarBody() {
  const group = new THREE.Group();

  // 재질 정의
  const bodyMat = new THREE.MeshStandardMaterial({ color: 0xe1e1e1, metalness: 0.6, roughness: 0.25 });
  const chromeMat = new THREE.MeshStandardMaterial({ color: 0xb0b0b0, metalness: 1.0, roughness: 0.05 });
  const glassMat = new THREE.MeshStandardMaterial({ color: 0x446688, transparent: true, opacity: 0.35, metalness: 0.3, roughness: 0.1 });
  const lightMat = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xffffff, emissiveIntensity: 2 });
  const rearLightMat = new THREE.MeshStandardMaterial({ color: 0xff2200, emissive: 0xff2200, emissiveIntensity: 1.5 });
  const blackMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.8 });
  const tireMat = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.5, roughness: 0.5 });

  // --- 1. 차체 바닥 & 옆면 기본 박스
  const bodyBase = new THREE.Mesh(new THREE.BoxGeometry(4.8, 0.7, 13.5), bodyMat);
  bodyBase.position.y = 0.35;
  group.add(bodyBase);

  // --- 2. 보닛 (앞부분 약간 높게, 경사 조절)
  const hoodShape = new THREE.Shape();
  hoodShape.moveTo(-2.3, 0);
  hoodShape.lineTo(2.3, 0);
  hoodShape.lineTo(2.3, 1.3);
  hoodShape.lineTo(-2.3, 1.3);
  hoodShape.lineTo(-2.3, 0);

  const hoodExtrudeSettings = { depth: 2.3, bevelEnabled: false };
  const hoodGeom = new THREE.ExtrudeGeometry(hoodShape, hoodExtrudeSettings);
  hoodGeom.rotateX(Math.PI / 2);
  hoodGeom.translate(0, 1.0, -6.6);

  const hood = new THREE.Mesh(hoodGeom, bodyMat);
  group.add(hood);

  // --- 3. 루프 (복잡한 곡선, Extrude + Bezier)
  const roofShape = new THREE.Shape();
  roofShape.moveTo(-2.1, 0);
  roofShape.bezierCurveTo(-1.5, 1.5, 1.5, 1.5, 2.1, 0);
  roofShape.lineTo(2.1, -5);
  roofShape.lineTo(-2.1, -5);
  roofShape.lineTo(-2.1, 0);

  const roofExtrudeSettings = { depth: 4.8, bevelEnabled: false };
  const roofGeom = new THREE.ExtrudeGeometry(roofShape, roofExtrudeSettings);
  roofGeom.rotateX(Math.PI / 2);
  roofGeom.translate(0, 1.5, -2);

  const roof = new THREE.Mesh(roofGeom, bodyMat);
  group.add(roof);

  // --- 4. 트렁크 (뒤쪽 약간 상승, 얇은 박스)
  const trunk = new THREE.Mesh(new THREE.BoxGeometry(4.6, 0.45, 2.5), bodyMat);
  trunk.position.set(0, 0.7, 6.2);
  group.add(trunk);

  // --- 5. 전면 그릴 (수직 슬랫 + 패턴)
  const grillGroup = new THREE.Group();
  const grillWidth = 3.8;
  const grillHeight = 1.0;
  const grillDepth = 0.15;

  for(let i=0; i<10; i++) {
    const thickness = (i%2 === 0) ? 0.2 : 0.1;
    const bar = new THREE.Mesh(new THREE.BoxGeometry(thickness, grillHeight, grillDepth), chromeMat);
    bar.position.set(-grillWidth/2 + i*(grillWidth/9), 0.75, -7.0);
    grillGroup.add(bar);
  }
  // 하단 가로바 2개 추가
  for(let j=0; j<2; j++) {
    const bar = new THREE.Mesh(new THREE.BoxGeometry(grillWidth, 0.12, grillDepth), chromeMat);
    bar.position.set(0, 0.3 + j*0.3, -7.05);
    grillGroup.add(bar);
  }
  group.add(grillGroup);

  // --- 6. 헤드라이트 (복잡한 슬림한 형태: 두 박스 합침)
  const headLightL = new THREE.Group();
  const mainHL = new THREE.Mesh(new THREE.BoxGeometry(0.9, 0.22, 0.15), lightMat);
  mainHL.position.set(0, 0, 0);
  const extraHL = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.2, 0.05), lightMat);
  extraHL.position.set(0.6, 0, 0.07);
  headLightL.add(mainHL, extraHL);
  headLightL.position.set(-2.3, 0.8, -7.05);

  const headLightR = headLightL.clone();
  headLightR.position.x = 2.3;
  group.add(headLightL, headLightR);

  // --- 7. 리어 램프 (긴 일자형, 앞뒤 얇게)
  const rearLight = new THREE.Mesh(new THREE.BoxGeometry(6.5, 0.25, 0.1), rearLightMat);
  rearLight.position.set(0, 1.1, 7.1);
  group.add(rearLight);

  // --- 8. 창문 (앞, 뒤, 옆 모두 분리)
  // 앞 유리
  const frontGlass = new THREE.Mesh(new THREE.PlaneGeometry(3.8, 1.3), glassMat);
  frontGlass.position.set(0, 1.3, -5.7);
  frontGlass.rotation.x = -Math.PI/6;
  group.add(frontGlass);
  // 뒷 유리
  const rearGlass = new THREE.Mesh(new THREE.PlaneGeometry(3.5, 1.0), glassMat);
  rearGlass.position.set(0, 1.2, 3.8);
  rearGlass.rotation.x = Math.PI/8;
  group.add(rearGlass);
  // 좌우 창문 (2개씩)
  const sideWindow1L = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.85, 4.0), glassMat);
  sideWindow1L.position.set(-2.5, 1.3, -0.8);
  const sideWindow2L = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.85, 4.5), glassMat);
  sideWindow2L.position.set(-2.5, 1.3, 2.3);
  const sideWindow1R = sideWindow1L.clone();
  sideWindow1R.position.x = 2.5;
  const sideWindow2R = sideWindow2L.clone();
  sideWindow2R.position.x = 2.5;
  group.add(sideWindow1L, sideWindow2L, sideWindow1R, sideWindow2R);

  // --- 9. 휠 하우스 (대형 토러스, 4개)
  const wheelPositions = [
    [-2.3, 0.3, -5.0],
    [2.3, 0.3, -5.0],
    [-2.3, 0.3, 5.0],
    [2.3, 0.3, 5.0],
  ];
  wheelPositions.forEach(([x,y,z]) => {
    const wheelArch = new THREE.Mesh(new THREE.TorusGeometry(1.05, 0.15, 24, 48, Math.PI), blackMat);
    wheelArch.rotation.x = Math.PI / 2;
    wheelArch.position.set(x, y+0.15, z);
    group.add(wheelArch);
  });

  // --- 10. 사이드 미러 (삼각뿔 + 기울기)
  const mirrorL = new THREE.Mesh(new THREE.ConeGeometry(0.15, 0.35, 20), blackMat);
  mirrorL.rotation.set(0, 0, -Math.PI / 2.5);
  mirrorL.position.set(-2.7, 1.4, -1.5);
  const mirrorR = mirrorL.clone();
  mirrorR.position.x = 2.7;
  group.add(mirrorL, mirrorR);

  // --- 11. 도어라인 (긴 얇은 박스)
  const doorLine = new THREE.Mesh(new THREE.BoxGeometry(4.7, 0.02, 12.3), chromeMat);
  doorLine.position.set(0, 0.95, 0);
  group.add(doorLine);

  // --- 12. 범퍼 (앞뒤)
  const bumperF = new THREE.Mesh(new THREE.BoxGeometry(4.2, 0.35, 0.45), blackMat);
  bumperF.position.set(0, 0.3, -7.3);
  const bumperR = bumperF.clone();
  bumperR.position.z = 7.3;
  group.add(bumperF, bumperR);

  return group;
  }

    // 차량용 RaycastVehicle 설정
    const vehicle = new CANNON.RaycastVehicle({
      chassisBody,
      indexRightAxis: 0, // x축이 차량 오른쪽
      indexUpAxis: 1,    // y축이 위
      indexForwardAxis: 2, // z축이 앞쪽
    });

    // 휠 옵션 - 디자인 및 물리 조정
    const wheelOptions = {
      radius: 0.5,
      directionLocal: new CANNON.Vec3(0, -1, 0),
      suspensionStiffness: 45,
      suspensionRestLength: 0.4,
      frictionSlip: 5,
      dampingRelaxation: 2.3,
      dampingCompression: 4.4,
      maxSuspensionForce: 1e4,
      rollInfluence: 0.02,
      axleLocal: new CANNON.Vec3(1, 0, 0),
      maxSuspensionTravel: 0.3,
      useCustomSlidingRotationalSpeed: true,
      customSlidingRotationalSpeed: -30,
    };

    // 휠 위치 및 앞바퀴 여부 설정
    [[-1.2, 0.2, 2.4, true], [1.2, 0.2, 2.4, true], [-1.2, 0.2, -2.4, false], [1.2, 0.2, -2.4, false]].forEach(
      ([x, y, z, isFront]) => {
        vehicle.addWheel({
          ...wheelOptions,
          chassisConnectionPointLocal: new CANNON.Vec3(x, y, z),
          isFrontWheel: isFront,
        });
      }
    );

    vehicle.addToWorld(world);

    // 휠 메시 생성 - 실제 타이어 모양에 가깝게 디자인 및 각도 조정
    const wheelHolders = [];
    vehicle.wheelInfos.forEach((wheel) => {
      const holder = new THREE.Group();
      scene.add(holder);
      wheelHolders.push(holder);

      const tireGeo = new THREE.CylinderGeometry(wheel.radius, wheel.radius, 0.4, 24);
      const tireMat = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.7, roughness: 0.4 });
      const tireMesh = new THREE.Mesh(tireGeo, tireMat);
      tireMesh.rotation.z = Math.PI / 2; // 눕히기
      holder.add(tireMesh);
    });

    // 조명 강화
    scene.add(new THREE.AmbientLight(0xffffff, 1));
    const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
    dirLight.position.set(10, 20, 10);
    scene.add(dirLight);

    // 입력 상태
    const input = { left: false, right: false, accel: false, brake: false };

    // DOM 요소 바인딩
    const btnLeft = document.getElementById('btnLeft'),
          btnRight = document.getElementById('btnRight'),
          btnAccel = document.getElementById('btnAccel'),
          btnBrake = document.getElementById('btnBrake'),
          gearDisplay = document.getElementById('gearDisplay'),
          gearButtons = [...document.querySelectorAll('#gearControls button')],
          hud = document.getElementById('hud'),
          timerDisplay = document.getElementById('timerDisplay');

    // 초기 기어 상태
    let gearState = 'P';

    // 키보드 입력 처리
    window.addEventListener('keydown', e => {
      switch(e.key.toLowerCase()) {
        case 'arrowleft':
        case 'a': input.left = true; break;
        case 'arrowright':
        case 'd': input.right = true; break;
        case 'arrowup':
        case 'w': input.accel = true; break;
        case 'arrowdown':
        case 's': input.brake = true; break;
        case '1': setGear('P'); break;
        case '2': setGear('R'); break;
        case '3': setGear('N'); break;
        case '4': setGear('D'); break;
      }
    });

    window.addEventListener('keyup', e => {
      switch(e.key.toLowerCase()) {
        case 'arrowleft':
        case 'a': input.left = false; break;
        case 'arrowright':
        case 'd': input.right = false; break;
        case 'arrowup':
        case 'w': input.accel = false; break;
        case 'arrowdown':
        case 's': input.brake = false; break;
      }
    });

    // 모바일 버튼 바인딩 함수
    function bindButton(button, prop) {
      const setTrue = e => { e.preventDefault(); input[prop] = true; };
      const setFalse = e => { e.preventDefault(); input[prop] = false; };
      button.addEventListener('mousedown', setTrue);
      button.addEventListener('mouseup', setFalse);
      button.addEventListener('touchstart', setTrue, { passive: false });
      button.addEventListener('touchend', setFalse, { passive: false });
      button.addEventListener('touchcancel', setFalse, { passive: false });
    }

    bindButton(btnLeft, 'left');
    bindButton(btnRight, 'right');
    bindButton(btnAccel, 'accel');
    bindButton(btnBrake, 'brake');

    // 브레이크 함수
    function applyBrake(force) {
      for(let i=0; i<4; i++) vehicle.setBrake(force, i);
    }

    // 기어 상태와 UI 업데이트 함수
    const maxEngineForce = 1200;
    const maxBrakeForce = 30;
    const maxSteerVal = Math.PI / 8;
    let engineForce = 0;
    let steeringValue = 0;

    function updateGearDisplay() {
      gearDisplay.textContent = `기어: ${gearState}`;
      const colorMap = { P: '#00ffff', R: '#ff5555', N: '#ffff55', D: '#55ff55' };
      gearDisplay.style.color = colorMap[gearState] || '#fff';
    }
    function setGear(gear) {
      gearState = gear;
      updateGearDisplay();
    }

    gearButtons.forEach(button => {
      button.addEventListener('click', () => setGear(button.textContent));
    });

    // 차량 조향, 가속, 브레이크 처리
    function updateVehicleControls() {
      // 조향: 좌우 키 또는 버튼에 따라 steeringValue 조절
      const steerSpeed = 0.01;  // 조향이 변화하는 속도 (더 작을수록 느리게 반응)

if (input.left) {
  steeringValue = Math.max(steeringValue - steerSpeed, -maxSteerVal);
} else if (input.right) {
  steeringValue = Math.min(steeringValue + steerSpeed, maxSteerVal);
} else {
  // 중립 방향으로 천천히 복귀
  if (steeringValue > 0) steeringValue = Math.max(steeringValue - steerSpeed, 0);
  else if (steeringValue < 0) steeringValue = Math.min(steeringValue + steerSpeed, 0);
}

      // 앞바퀴 조향에 적용
      vehicle.setSteeringValue(steeringValue, 0);
      vehicle.setSteeringValue(steeringValue, 1);

      vehicle.setSteeringValue(0, 2); // 뒷왼쪽 바퀴 → 조향 없음
      vehicle.setSteeringValue(0, 3); // 뒷오른쪽 바퀴 → 조향 없음
      // 엔진 힘 초기화
      engineForce = 0;

      // 기어별 힘 전달
      if (gearState === 'D') {
        if (input.accel) engineForce = maxEngineForce;
        if (input.brake) applyBrake(maxBrakeForce);
        else applyBrake(0);
      } else if (gearState === 'R') {
        if (input.accel) engineForce = -maxEngineForce * 0.6; // 후진은 힘 약간 줄임
        if (input.brake) applyBrake(maxBrakeForce);
        else applyBrake(0);
      } else if (gearState === 'N') {
        applyBrake(input.brake ? maxBrakeForce : 0);
        engineForce = 0;
      } else if (gearState === 'P') {
        applyBrake(maxBrakeForce * 1.5); // 주차브레이크 강하게
        engineForce = 0;
      }

      // 엔진 힘 앞바퀴에 적용 (후륜 구동 가정)
      vehicle.applyEngineForce(engineForce, 2);
      vehicle.applyEngineForce(engineForce, 3);
    }

    // 속도 측정 (m/s -> km/h)
    function getSpeedKmH() {
      const velocity = chassisBody.velocity;
      return velocity.length() * 3.6;
    }

    // 카메라 차량 뒤쪽 위치로 고정
    function updateCamera() {
  const relativeCameraOffset = new THREE.Vector3(0, 7, 15);
  const cameraOffset = relativeCameraOffset.applyMatrix4(carMesh.matrixWorld);
  camera.position.lerp(cameraOffset, 0.1);
  camera.lookAt(carMesh.position);
    }

    // 타이머 관리
    let startTime = null;
    let elapsedTime = 0;

    function startTimer() {
      startTime = performance.now();
    }

    function updateTimer() {
      if (startTime === null) return;
      elapsedTime = (performance.now() - startTime) / 1000;
      timerDisplay.textContent = `타이머: ${elapsedTime.toFixed(2)} s`;
    }

    // 애니메이션 및 물리 루프
    const clock = new THREE.Clock();

    function animate() {
      
      requestAnimationFrame(animate);

      const delta = clock.getDelta();

      updateVehicleControls();

      world.step(1/60, delta, 3);

      // 차량 위치/회전 mesh에 반영
      carMesh.position.copy(chassisBody.position);
carMesh.quaternion.copy(chassisBody.quaternion);

      // 휠 mesh 위치/회전 업데이트
      for (let i = 0; i < vehicle.wheelInfos.length; i++) {
        vehicle.updateWheelTransform(i);
        const t = vehicle.wheelInfos[i].worldTransform;
        wheelHolders[i].position.copy(t.position);
        wheelHolders[i].quaternion.copy(t.quaternion);
      }

      // 속도 UI 업데이트
      hud.textContent = `속도: ${getSpeedKmH().toFixed(1)} km/h`;

      // 카메라 따라가기
      updateCamera();

      // 타이머 업데이트
      updateTimer();

      renderer.render(scene, camera);
    }

    startTimer();
    updateGearDisplay();
    animate();
  </script>
</body>
</html>
