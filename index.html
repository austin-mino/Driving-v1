<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>완성형 3D 자동차 게임</title>
<style>
  html, body {
    margin:0; padding:0; overflow:hidden; background:#222;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    user-select:none; -webkit-user-select:none; -moz-user-select:none; -ms-user-select:none;
  }
  #hud {
    position: fixed; left: 10px; top: 10px; color: #0f0; font-weight: bold; font-size: 18px;
    background: rgba(0,0,0,0.6); padding: 8px 16px; border-radius: 12px; width: 150px;
    user-select:none;
    z-index: 100;
  }
  #gearbox {
    position: fixed; right: 10px; top: 10px; width: 60px; background: rgba(0,0,0,0.6);
    border-radius: 12px; padding: 8px; color: white; font-weight: bold; font-size: 20px;
    user-select:none;
    z-index: 100;
    display: flex; flex-direction: column; gap: 6px;
  }
  .gear-button {
    background: #444; border-radius: 8px; padding: 8px; cursor: pointer; text-align: center;
    transition: background 0.3s;
    user-select:none;
  }
  .gear-button.active {
    background: #0f0;
    color: black;
    font-weight: 900;
  }
  #controls-left, #controls-right {
    position: fixed; bottom: 20px; display: flex; gap: 12px; user-select:none;
  }
  #controls-left {
    left: 20px;
  }
  #controls-right {
    right: 20px;
  }
  button.control-btn {
    width: 72px; height: 72px; border-radius: 50%; border: none; background: #0a74da;
    color: white; font-size: 20px; font-weight: 700; cursor: pointer;
    box-shadow: 0 0 10px #0a74da;
    transition: background 0.2s ease;
    user-select:none;
  }
  button.control-btn:active {
    background: #074c85;
  }
</style>
</head>
<body>

<div id="hud">
  속도: <span id="speed">0</span> km/h<br/>
  기어: <span id="currentGear">P</span>
</div>

<div id="gearbox">
  <div class="gear-button active" data-gear="P">P</div>
  <div class="gear-button" data-gear="R">R</div>
  <div class="gear-button" data-gear="N">N</div>
  <div class="gear-button" data-gear="D">D</div>
</div>

<div id="controls-left">
  <button class="control-btn" id="btn-left">◀</button>
  <button class="control-btn" id="btn-right">▶</button>
</div>
<div id="controls-right">
  <button class="control-btn" id="btn-accel">▲</button>
  <button class="control-btn" id="btn-brake">▼</button>
</div>

<script type="module">

// Import three.js and cannon-es modules
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js';
import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js';

/** 1) 물리엔진 세팅 **/
const world = new CANNON.World({
  gravity: new CANNON.Vec3(0, -9.82, 0),
  broadphase: new CANNON.SAPBroadphase(),
  allowSleep: true
});
world.defaultContactMaterial.friction = 0.5;

const groundMaterial = new CANNON.Material('groundMaterial');
const wheelMaterial = new CANNON.Material('wheelMaterial');
const wheelGroundContactMaterial = new CANNON.ContactMaterial(wheelMaterial, groundMaterial, {
  friction: 1.0,
  restitution: 0,
  contactEquationStiffness: 1e7,
  contactEquationRelaxation: 3,
});
world.addContactMaterial(wheelGroundContactMaterial);

/** 2) THREE.js 세팅 **/
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x111111);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 2000);
camera.position.set(0, 6, -14);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

/** 3) 조명 **/
const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
scene.add(ambientLight);

const dirLight = new THREE.DirectionalLight(0xffffff, 1);
dirLight.position.set(15, 25, 15);
dirLight.castShadow = true;
dirLight.shadow.mapSize.width = 2048;
dirLight.shadow.mapSize.height = 2048;
dirLight.shadow.camera.left = -30;
dirLight.shadow.camera.right = 30;
dirLight.shadow.camera.top = 30;
dirLight.shadow.camera.bottom = -30;
scene.add(dirLight);

/** 4) 바닥 **/
const groundGeo = new THREE.PlaneGeometry(800, 800);
const groundMat = new THREE.MeshStandardMaterial({color: 0x444444});
const groundMesh = new THREE.Mesh(groundGeo, groundMat);
groundMesh.rotation.x = -Math.PI/2;
groundMesh.receiveShadow = true;
scene.add(groundMesh);

const groundBody = new CANNON.Body({
  mass: 0,
  shape: new CANNON.Plane(),
  material: groundMaterial
});
groundBody.quaternion.setFromEuler(-Math.PI/2, 0, 0);
world.addBody(groundBody);

/** 5) 자동차 차체 및 물리세팅 **/
const chassisShape = new CANNON.Box(new CANNON.Vec3(1.7, 0.6, 3.5));
const chassisBody = new CANNON.Body({ mass: 180 });
chassisBody.addShape(chassisShape);
chassisBody.position.set(0, 2, 0);
chassisBody.angularDamping = 0.5;
world.addBody(chassisBody);

/** THREE.js 자동차 그룹 및 바디 모델 **/
const carGroup = new THREE.Group();

const bodyMat = new THREE.MeshStandardMaterial({color: 0xff2200, metalness: 0.7, roughness: 0.3});
const bodyGeo = new THREE.BoxGeometry(3.4, 1.2, 7);
const bodyMesh = new THREE.Mesh(bodyGeo, bodyMat);
bodyMesh.castShadow = true;
bodyMesh.receiveShadow = true;
bodyMesh.position.y = 0.6;
carGroup.add(bodyMesh);

// 창문 (반투명)
const windowMat = new THREE.MeshStandardMaterial({color: 0x4455aa, opacity: 0.5, transparent: true, roughness: 0.1});
const frontWindowGeo = new THREE.BoxGeometry(3.1, 0.8, 0.15);
const frontWindow = new THREE.Mesh(frontWindowGeo, windowMat);
frontWindow.position.set(0, 1.0, -1.4);
carGroup.add(frontWindow);

const rearWindow = frontWindow.clone();
rearWindow.position.set(0, 1.0, 1.4);
carGroup.add(rearWindow);

const leftWindowGeo = new THREE.BoxGeometry(0.15, 0.8, 2.8);
const leftWindow = new THREE.Mesh(leftWindowGeo, windowMat);
leftWindow.position.set(-1.7, 1.0, 0);
carGroup.add(leftWindow);

const rightWindow = leftWindow.clone();
rightWindow.position.set(1.7, 1.0, 0);
carGroup.add(rightWindow);

scene.add(carGroup);

/** 6) RaycastVehicle 세팅 **/
const vehicle = new CANNON.RaycastVehicle({
  chassisBody: chassisBody,
  indexRightAxis: 0,
  indexUpAxis: 1,
  indexForwardAxis: 2
});

// 휠 옵션
const wheelOptions = {
  radius: 0.7,
  directionLocal: new CANNON.Vec3(0, -1, 0),
  suspensionStiffness: 50,
  suspensionRestLength: 0.35,
  axleLocal: new CANNON.Vec3(-1, 0, 0),
  frictionSlip: 6,
  dampingRelaxation: 2.3,
  dampingCompression: 4.4,
  maxSuspensionForce: 1e5,
  rollInfluence: 0.02,
  maxSuspensionTravel: 0.3,
  customSlidingRotationalSpeed: -30,
  useCustomSlidingRotationalSpeed: true,
  maxSuspensionForce: 5000
};

// 앞 바퀴
vehicle.addWheel({...wheelOptions, chassisConnectionPointLocal: new CANNON.Vec3(-1.5, 0.4, 3.1), isFrontWheel: true});
vehicle.addWheel({...wheelOptions, chassisConnectionPointLocal: new CANNON.Vec3(1.5, 0.4, 3.1), isFrontWheel: true});

// 뒷 바퀴
vehicle.addWheel({...wheelOptions, chassisConnectionPointLocal: new CANNON.Vec3(-1.5, 0.4, -3.1), isFrontWheel: false});
vehicle.addWheel({...wheelOptions, chassisConnectionPointLocal: new CANNON.Vec3(1.5, 0.4, -3.1), isFrontWheel: false});

vehicle.addToWorld(world);

// 바퀴 메쉬 생성
const wheelMeshes = [];
const wheelGeo = new THREE.CylinderGeometry(wheelOptions.radius, wheelOptions.radius, 0.6, 32);
const wheelMat = new THREE.MeshStandardMaterial({color: 0x111111, metalness: 0.8, roughness: 0.6});

for(let i=0; i<vehicle.wheelInfos.length; i++){
  const mesh = new THREE.Mesh(wheelGeo, wheelMat);
  mesh.rotation.z = Math.PI/2;
  mesh.castShadow = true;
  scene.add(mesh);
  wheelMeshes.push(mesh);
}

/** 7) 입력 처리 **/
const inputState = {
  steer: 0,   // -1 ~ +1
  accel: false,
  brake: false,
  gear: 'P'
};

// 키보드 (PC) 제어
window.addEventListener('keydown', (e) => {
  switch(e.code){
    case 'ArrowLeft': inputState.steer = -1; break;
    case 'ArrowRight': inputState.steer = 1; break;
    case 'ArrowUp': inputState.accel = true; break;
    case 'ArrowDown': inputState.brake = true; break;
  }
});
window.addEventListener('keyup', (e) => {
  switch(e.code){
    case 'ArrowLeft': if(inputState.steer === -1) inputState.steer = 0; break;
    case 'ArrowRight': if(inputState.steer === 1) inputState.steer = 0; break;
    case 'ArrowUp': inputState.accel = false; break;
    case 'ArrowDown': inputState.brake = false; break;
  }
});

// 모바일 버튼 처리
function bindButton(id, actionTrue, actionFalse){
  const btn = document.getElementById(id);
  btn.addEventListener('pointerdown', e => { e.preventDefault(); actionTrue(); });
  btn.addEventListener('pointerup', e => { e.preventDefault(); actionFalse(); });
  btn.addEventListener('pointerleave', e => { e.preventDefault(); actionFalse(); });
  btn.addEventListener('touchstart', e => { e.preventDefault(); actionTrue(); });
  btn.addEventListener('touchend', e => { e.preventDefault(); actionFalse(); });
}
bindButton('btn-left', () => inputState.steer = -1, () => { if(inputState.steer === -1) inputState.steer=0; });
bindButton('btn-right', () => inputState.steer = 1, () => { if(inputState.steer === 1) inputState.steer=0; });
bindButton('btn-accel', () => inputState.accel = true, () => inputState.accel = false);
bindButton('btn-brake', () => inputState.brake = true, () => inputState.brake = false);

// 기어 버튼 처리
const gearButtons = document.querySelectorAll('.gear-button');
gearButtons.forEach(btn=>{
  btn.addEventListener('click', () => {
    const selectedGear = btn.getAttribute('data-gear');
    if(canShiftGear(selectedGear)) {
      inputState.gear = selectedGear;
      updateGearUI();
    }
  });
});

function canShiftGear(newGear){
  const speed = chassisBody.velocity.length();
  if(newGear === inputState.gear) return false;
  if((newGear==='R' || newGear==='P') && speed > 0.1) return false;
  if((inputState.gear==='D' && newGear==='R' || inputState.gear==='R' && newGear==='D') && speed > 1) return false;
  return true;
}
function updateGearUI(){
  gearButtons.forEach(btn => {
    if(btn.getAttribute('data-gear') === inputState.gear) btn.classList.add('active');
    else btn.classList.remove('active');
  });
  document.getElementById('currentGear').textContent = inputState.gear;
}
updateGearUI();

/** 8) 물리 시뮬레이션 파라미터 **/
const maxSteerAngle = Math.PI/6; // 약 30도
const maxEngineForce = 6000;
const maxBrakeForce = 100000;

/** 9) 게임 루프 **/
let lastTime = performance.now();

function gameLoop(){
  requestAnimationFrame(gameLoop);

  const now = performance.now();
  const dt = (now - lastTime) / 1000;
  lastTime = now;

  // 조향 값 부드럽게 보간
  const targetSteer = inputState.steer * maxSteerAngle;
  const currentSteerL = vehicle.wheelInfos[0].steerValue;
  const currentSteerR = vehicle.wheelInfos[1].steerValue;
  const lerpSteerL = currentSteerL + (targetSteer - currentSteerL) * 0.15;
  const lerpSteerR = currentSteerR + (targetSteer - currentSteerR) * 0.15;
  vehicle.setSteeringValue(lerpSteerL, 0);
  vehicle.setSteeringValue(lerpSteerR, 1);

  // 엔진과 브레이크 힘 초기화
  let engineForce = 0;
  let brakeForce = 0;

  switch(inputState.gear) {
    case 'P':
      brakeForce = maxBrakeForce; // 주차 브레이크
      break;
    case 'N':
      brakeForce = inputState.brake ? maxBrakeForce/4 : 0;
      break;
    case 'R':
      if(inputState.accel) engineForce = maxEngineForce;
      brakeForce = inputState.brake ? maxBrakeForce/2 : 0;
      break;
    case 'D':
      if(inputState.accel) engineForce = -maxEngineForce;
      brakeForce = inputState.brake ? maxBrakeForce/2 : 0;
      break;
  }

  vehicle.applyEngineForce(engineForce, 2);
  vehicle.applyEngineForce(engineForce, 3);

  for(let i=0; i<4; i++) vehicle.setBrake(brakeForce, i);

  // 물리 스텝
  world.step(1/60, dt, 10);

  // 자동차 위치/회전 업데이트
  carGroup.position.copy(chassisBody.position);
  carGroup.quaternion.copy(chassisBody.quaternion);

  // 휠 위치/회전 업데이트
  vehicle.wheelInfos.forEach((wheel, i) => {
    vehicle.updateWheelTransform(i);
    const t = wheel.worldTransform;
    wheelMeshes[i].position.copy(t.position);
    wheelMeshes[i].quaternion.copy(t.quaternion);
  });

  // 카메라 부드럽게 자동차 뒤 따라가기
  const relativeCameraOffset = new THREE.Vector3(0, 4, -10);
  const cameraOffset = relativeCameraOffset.applyMatrix4(carGroup.matrixWorld);

  camera.position.lerp(cameraOffset, 0.1);
  camera.lookAt(carGroup.position);

  // HUD 업데이트
  const velocity = chassisBody.velocity.length();
  const speedKmh = Math.floor(velocity * 3.6);
  document.getElementById('speed').textContent = speedKmh;

  renderer.render(scene, camera);
}

gameLoop();

</script>
</body>
</html>
