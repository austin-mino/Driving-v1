<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>완벽한 3D 자동차 게임</title>
<style>
  body { margin:0; overflow:hidden; background:#000; font-family: Arial,sans-serif; color:#fff; }
  #rotateWarning {
    position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
    background: rgba(0,0,0,0.8); padding: 20px; border-radius: 10px;
    display: none; z-index: 99;
  }

  /* HUD 스타일 */
  #speedDisplay {
    position: fixed; top: 10px; left: 10px;
    background: rgba(0,0,0,0.6); padding: 10px 20px;
    border-radius: 10px; font-weight: bold; font-size: 20px;
    z-index: 15;
  }
  #gearDisplay {
    position: fixed; top: 10px; right: 10px;
    background: rgba(0,0,0,0.6); padding: 10px 20px;
    border-radius: 10px; font-weight: bold; font-size: 20px;
    z-index: 15;
  }

  /* 버튼 영역 */
  #buttonsLeft, #buttonsRight {
    position: fixed; bottom: 20px; display: flex; gap: 12px; z-index: 15;
  }
  #buttonsLeft {
    left: 20px;
  }
  #buttonsRight {
    right: 20px;
  }
  button {
    padding: 14px 20px;
    border-radius: 12px;
    border: none;
    background: #4f9eff;
    color: white;
    font-weight: 700;
    font-size: 16px;
    cursor: pointer;
    user-select: none;
    touch-action: manipulation;
    transition: background 0.15s ease-in-out;
  }
  button:active {
    background: #367ed9;
  }

  /* 기어 버튼 */
  #gearButtons {
    position: fixed; top: 60px; right: 10px;
    display: flex; flex-direction: column; gap: 10px;
    z-index: 20;
  }
  #gearButtons button {
    width: 50px;
  }
</style>
</head>
<body>

<div id="rotateWarning">가로 모드로 전환해주세요</div>

<div id="speedDisplay">속도: 0 km/h</div>
<div id="gearDisplay">기어: P</div>

<div id="buttonsLeft">
  <button id="leftBtn">◀ 좌</button>
  <button id="rightBtn">우 ▶</button>
</div>

<div id="buttonsRight">
  <button id="accelBtn">엑셀</button>
  <button id="brakeBtn">브레이크</button>
</div>

<div id="gearButtons">
  <button data-gear="P">P</button>
  <button data-gear="R">R</button>
  <button data-gear="N">N</button>
  <button data-gear="D">D</button>
</div>

<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js';
import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js';

// 가로모드 체크 및 경고창
const rotateWarning = document.getElementById('rotateWarning');
function checkOrientation() {
  rotateWarning.style.display = window.innerHeight > window.innerWidth ? 'block' : 'none';
}
window.addEventListener('resize', checkOrientation);
window.addEventListener('orientationchange', checkOrientation);
checkOrientation();

// --- THREE.js 초기화 ---
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x202020);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 2000);
camera.position.set(0, 5, -10);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

// 조명
const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
scene.add(ambientLight);

const dirLight = new THREE.DirectionalLight(0xffffff, 1);
dirLight.position.set(10, 20, 10);
scene.add(dirLight);

// --- Cannon-es 물리세계 초기화 ---
const world = new CANNON.World({
  gravity: new CANNON.Vec3(0, -9.82, 0),
  broadphase: new CANNON.SAPBroadphase(),
  allowSleep: true,
});
world.defaultContactMaterial.friction = 0.6;

// 바닥 (시각+물리)
const groundGeo = new THREE.PlaneGeometry(1000, 1000);
const groundMat = new THREE.MeshStandardMaterial({color: 0x222222});
const groundMesh = new THREE.Mesh(groundGeo, groundMat);
groundMesh.rotation.x = -Math.PI / 2;
scene.add(groundMesh);

const groundBody = new CANNON.Body({
  mass: 0,
  shape: new CANNON.Plane(),
  material: new CANNON.Material('groundMaterial')
});
groundBody.quaternion.setFromEuler(-Math.PI/2, 0, 0);
world.addBody(groundBody);

// 바닥용 마찰력 조절
const groundContactMat = new CANNON.ContactMaterial(
  groundBody.material,
  world.defaultContactMaterial,
  { friction: 0.9, restitution: 0.1 }
);
world.addContactMaterial(groundContactMat);

// --- 자동차 차체 및 차량 생성 ---
const chassisShape = new CANNON.Box(new CANNON.Vec3(1.5, 0.4, 3));
const chassisBody = new CANNON.Body({ mass: 150 });
chassisBody.addShape(chassisShape);
chassisBody.position.set(0, 1, 0);
world.addBody(chassisBody);

const chassisMesh = new THREE.Group();

// 차체 - 붉은색 박스 (실제 자동차 형태에 가깝게)
const bodyGeometry = new THREE.BoxGeometry(3, 0.8, 6);
const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0xff3333, metalness: 0.6, roughness: 0.4 });
const bodyMesh = new THREE.Mesh(bodyGeometry, bodyMaterial);
bodyMesh.position.y = 0.4;
chassisMesh.add(bodyMesh);

// 지붕
const roofGeometry = new THREE.BoxGeometry(2.4, 0.4, 3);
const roofMaterial = new THREE.MeshStandardMaterial({ color: 0xaa2222, metalness: 0.5, roughness: 0.5 });
const roofMesh = new THREE.Mesh(roofGeometry, roofMaterial);
roofMesh.position.set(0, 0.85, 0);
chassisMesh.add(roofMesh);

// 창문 (투명)
const windowMaterial = new THREE.MeshStandardMaterial({color: 0x3333aa, opacity: 0.5, transparent: true, roughness: 0.1});
const frontWindowGeo = new THREE.BoxGeometry(2.3, 0.4, 0.05);
const frontWindow = new THREE.Mesh(frontWindowGeo, windowMaterial);
frontWindow.position.set(0, 0.85, -1.45);
chassisMesh.add(frontWindow);

const rearWindow = frontWindow.clone();
rearWindow.position.set(0, 0.85, 1.45);
chassisMesh.add(rearWindow);

const sideWindowGeo = new THREE.BoxGeometry(0.05, 0.4, 3);
const leftWindow = new THREE.Mesh(sideWindowGeo, windowMaterial);
leftWindow.position.set(-1.25, 0.85, 0);
chassisMesh.add(leftWindow);

const rightWindow = leftWindow.clone();
rightWindow.position.set(1.25, 0.85, 0);
chassisMesh.add(rightWindow);

scene.add(chassisMesh);

// --- 바퀴 생성 및 차량 설정 ---
const vehicle = new CANNON.RaycastVehicle({
  chassisBody: chassisBody,
  indexUpAxis: 1,
  indexRightAxis: 0,
  indexForwardAxis: 2
});

const wheelMaterial = new THREE.MeshStandardMaterial({color: 0x111111, metalness: 0.8, roughness: 0.7});

const wheelOptions = {
  radius: 0.6,
  directionLocal: new CANNON.Vec3(0, -1, 0),
  suspensionStiffness: 30,
  suspensionRestLength: 0.3,
  axleLocal: new CANNON.Vec3(-1, 0, 0),
  frictionSlip: 5,
  dampingRelaxation: 2.3,
  dampingCompression: 4.4,
  maxSuspensionForce: 1e4,
  rollInfluence: 0.01,
  maxSuspensionTravel: 0.3,
  customSlidingRotationalSpeed: -30,
  useCustomSlidingRotationalSpeed: true
};

// 앞바퀴 (조향 가능)
vehicle.addWheel({...wheelOptions, chassisConnectionPointLocal: new CANNON.Vec3(-1.2, 0.1, 2.1), isFrontWheel: true});
vehicle.addWheel({...wheelOptions, chassisConnectionPointLocal: new CANNON.Vec3( 1.2, 0.1, 2.1), isFrontWheel: true});

// 뒷바퀴 (조향 불가)
vehicle.addWheel({...wheelOptions, chassisConnectionPointLocal: new CANNON.Vec3(-1.2, 0.1, -2.1), isFrontWheel: false});
vehicle.addWheel({...wheelOptions, chassisConnectionPointLocal: new CANNON.Vec3( 1.2, 0.1, -2.1), isFrontWheel: false});

vehicle.addToWorld(world);

// 바퀴 메시 배열
const wheelMeshes = [];
vehicle.wheelInfos.forEach(wheel => {
  const geometry = new THREE.CylinderGeometry(wheel.radius, wheel.radius, 0.5, 24);
  const mesh = new THREE.Mesh(geometry, wheelMaterial);
  mesh.rotation.z = Math.PI / 2;
  scene.add(mesh);
  wheelMeshes.push(mesh);
});

// --- 차량 제어 및 상태 변수 ---
let currentGear = 'P';  // P, R, N, D

const speedDisplay = document.getElementById('speedDisplay');
const gearDisplay = document.getElementById('gearDisplay');

// 입력 상태 객체
const inputState = {
  left: false,
  right: false,
  accel: false,
  brake: false
};

// 버튼 이벤트 바인딩 함수
function bindButton(id, key) {
  const btn = document.getElementById(id);
  btn.addEventListener('pointerdown', () => inputState[key] = true);
  btn.addEventListener('pointerup', () => inputState[key] = false);
  btn.addEventListener('pointerleave', () => inputState[key] = false);
  btn.addEventListener('touchstart', e => { e.preventDefault(); inputState[key] = true; }, {passive:false});
  btn.addEventListener('touchend', e => { e.preventDefault(); inputState[key] = false; }, {passive:false});
}
bindButton('leftBtn', 'left');
bindButton('rightBtn', 'right');
bindButton('accelBtn', 'accel');
bindButton('brakeBtn', 'brake');

// 기어 버튼 이벤트 연결
document.querySelectorAll('#gearButtons button').forEach(btn => {
  btn.addEventListener('pointerdown', () => tryShiftGear(btn.dataset.gear));
});

// 기어 변경 함수 (안전하게 속도 체크해서 변경)
function tryShiftGear(newGear) {
  if (newGear === currentGear) return;
  const speed = chassisBody.velocity.length();

  if (newGear === 'P' && speed > 0.1) return;
  if ((newGear === 'R' || newGear === 'D') && speed > 1) return;

  currentGear = newGear;
  gearDisplay.textContent = `기어: ${currentGear}`;

  if (currentGear === 'P') {
    vehicle.setBrake(1e5, 0);
    vehicle.setBrake(1e5, 1);
    vehicle.setBrake(1e5, 2);
    vehicle.setBrake(1e5, 3);
  } else {
    vehicle.setBrake(0, 0);
    vehicle.setBrake(0, 1);
    vehicle.setBrake(0, 2);
    vehicle.setBrake(0, 3);
  }
}

// --- 주행 관련 변수 ---
const maxSteerVal = Math.PI / 6; // 최대 조향 각도 30도
const maxForceForward = 6000;
const maxForceReverse = 2000;
const brakeForceMax = 500;

let steerValue = 0;
let engineForce = 0;
let brakeForce = 0;

// 시간 관리용
let lastTime = performance.now();

// --- 메인 애니메이션 및 물리 루프 ---
function animate() {
  requestAnimationFrame(animate);

  const now = performance.now();
  const deltaTime = (now - lastTime) / 1000;
  lastTime = now;

  // --- 스티어링 처리 ---
  if(inputState.left) steerValue = Math.min(steerValue + 0.04, maxSteerVal);
  else if(inputState.right) steerValue = Math.max(steerValue - 0.04, -maxSteerVal);
  else steerValue *= 0.8; // 점차 중립으로

  vehicle.setSteeringValue(steerValue, 0);
  vehicle.setSteeringValue(steerValue, 1);

  // --- 엔진/브레이크 힘 계산 ---
  engineForce = 0;
  brakeForce = 0;

  if(currentGear === 'D') {
    if(inputState.accel) engineForce = maxForceForward;
    if(inputState.brake) brakeForce = brakeForceMax;
  } else if(currentGear === 'R') {
    if(inputState.accel) engineForce = -maxForceReverse;
    if(inputState.brake) brakeForce = brakeForceMax;
  } else if(currentGear === 'P') {
    brakeForce = 1e5;
  } else if(currentGear === 'N') {
    if(inputState.brake) brakeForce = brakeForceMax;
  }

  // 힘 적용
  vehicle.applyEngineForce(engineForce, 2);
  vehicle.applyEngineForce(engineForce, 3);

  vehicle.setBrake(brakeForce, 0);
  vehicle.setBrake(brakeForce, 1);
  vehicle.setBrake(brakeForce, 2);
  vehicle.setBrake(brakeForce, 3);

  // 물리 세계 스텝 진행
  world.step(1/60, deltaTime, 10);

  // 차체 메시 위치 동기화
  chassisMesh.position.copy(chassisBody.position);
  chassisMesh.quaternion.copy(chassisBody.quaternion);

  // 바퀴 위치 동기화
  vehicle.wheelInfos.forEach((wheel, idx) => {
    vehicle.updateWheelTransform(idx);
    const t = wheel.worldTransform;
    wheelMeshes[idx].position.copy(t.position);
    wheelMeshes[idx].quaternion.copy(t.quaternion);
  });

  // 카메라 위치 조정 (자동차 뒤쪽, 위쪽 고정)
  const carPos = chassisMesh.position.clone();
  const carQuat = chassisMesh.quaternion.clone();

  const camOffset = new THREE.Vector3(0, 3, -8);
  camOffset.applyQuaternion(carQuat);
  const desiredCamPos = carPos.clone().add(camOffset);

  camera.position.lerp(desiredCamPos, 0.1);
  camera.lookAt(carPos);

  // 속도 표시 (km/h)
  const speedKmh = chassisBody.velocity.length() * 3.6;
  speedDisplay.textContent = `속도: ${Math.round(speedKmh)} km/h`;

  renderer.render(scene, camera);
}

animate();

</script>
</body>
</html>
