<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>3D driving</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #121212;
      font-family: 'Segoe UI', Tahoma, Verdana, sans-serif;
      color: #fff;
      user-select: none;
    }
    #rotateWarning {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.85);
      padding: 25px 40px;
      border-radius: 15px;
      font-size: 1.3rem;
      font-weight: bold;
      z-index: 1000;
      display: none;
    }
    #hud, #gearDisplay, #timerDisplay {
      position: fixed;
      background: rgba(0, 0, 0, 0.7);
      padding: 12px 18px;
      border-radius: 10px;
      font-weight: 700;
      font-size: 18px;
      user-select: none;
      z-index: 100;
    }
    #hud { top: 20px; left: 20px; }
    #gearDisplay { top: 10px; right: 20px; }
    #timerDisplay { top: 60px; left: 20px; }
    #gearControls {
      position: fixed;
      top: 50px;
      right: 20px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      z-index: 100;
    }
    #controlsLeft, #driveControls {
      position: fixed;
      bottom: 20px;
      display: flex;
      gap: 15px;
      z-index: 100;
      user-select: none;
    }
    #controlsLeft { left: 20px; }
    #driveControls { right: 20px; }
    button.controlBtn {
      padding: 14px 20px;
      border-radius: 12px;
      border: none;
      background: #0078d7;
      color: #fff;
      font-weight: 700;
      font-size: 16px;
      cursor: pointer;
      touch-action: manipulation;
      transition: background-color 0.2s, color 0.2s;
    }
    button.controlBtn:active {
      background: #005a9e;
    }
    @media (max-width: 600px) {
      button.controlBtn {
        padding: 18px 22px;
        font-size: 20px;
      }
    }
  </style>
</head>
<body>
  <div id="rotateWarning">ê°€ë¡œ ëª¨ë“œë¡œ ì „í™˜í•´ì£¼ì„¸ìš”</div>
  <div id="hud">ì†ë„: 0 km/h</div>
  <div id="timerDisplay">íƒ€ì´ë¨¸: 0.00 s</div>
  <div id="gearDisplay">ê¸°ì–´: P</div>

  <!-- ì¢Œ/ìš° ìŠ¤í‹°ì–´ë§ -->
  <div id="controlsLeft">
    <button id="btnLeft" class="controlBtn">â—€ ì¢Œ</button>
    <button id="btnRight" class="controlBtn">ìš° â–¶</button>
  </div>
  <!-- ì—‘ì…€Â·ë¸Œë ˆì´í¬ -->
  <div id="driveControls">
    <button id="btnAccel" class="controlBtn">ì—‘ì…€</button>
    <button id="btnBrake" class="controlBtn">ë¸Œë ˆì´í¬</button>
  <div id="reset">
    <!-- ê¸°ì–´ ì„ íƒ ì•„ë˜ì— ì¶”ê°€ -->
    <button id="btnReset" class="controlBtn">ì°¨ëŸ‰ ë¦¬ì…‹</button>
  </div>
    <!-- ê¸°ì–´ ì„ íƒ -->
  <div id="gearControls">
    <button id="gearP" class="controlBtn">P</button>
    <button id="gearR" class="controlBtn">R</button>
    <button id="gearN" class="controlBtn">N</button>
    <button id="gearD" class="controlBtn">D</button>
  </div>

  <script type="module">
  import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js';
  import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/loaders/GLTFLoader.js';
  import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js';

    // ê°€ë¡œëª¨ë“œ ì²´í¬
    const rotateWarning = document.getElementById('rotateWarning');
    function checkOrientation() {
      rotateWarning.style.display = window.innerHeight > window.innerWidth ? 'block' : 'none';
    }
    window.addEventListener('resize', checkOrientation);
    window.addEventListener('orientationchange', checkOrientation);
    checkOrientation();

    // Three.js ê¸°ë³¸ ì„¤ì •
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x222222);
    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.05, 5000);
    camera.position.set(500, 5, 15);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
document.getElementById('btnReset').addEventListener('click', resetCar);
window.addEventListener('keydown', e => {
  if (e.key.toLowerCase() === 'r') resetCar();
});

function resetCar() {
  // ìœ„ì¹˜ëŠ” ê·¸ëŒ€ë¡œ, ë†’ì´ ì•½ê°„ ìœ„ë¡œ
  const pos = chassisBody.position;
  chassisBody.position.set(pos.x, pos.y + 1.5, pos.z);

  // íšŒì „ ì´ˆê¸°í™” (yì¶•ì€ ìœ ì§€í•´ì„œ ë°©í–¥ì€ ê·¸ëŒ€ë¡œ)
  const yRot = getYRotation(chassisBody.quaternion);
  chassisBody.quaternion.setFromEuler(0, yRot, 0);

  // ì†ë„ ì´ˆê¸°í™”
  chassisBody.velocity.set(0, 0, 0);
  chassisBody.angularVelocity.set(0, 0, 0);
}
    
// ì¿¼í„°ë‹ˆì–¸ì—ì„œ yì¶• íšŒì „ê°’ ì¶”ì¶œ
function getYRotation(q) {
  const siny_cosp = 2 * (q.w * q.y + q.z * q.x);
  const cosy_cosp = 1 - 2 * (q.y * q.y + q.z * q.z);
  return Math.atan2(siny_cosp, cosy_cosp);
}
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 1. ì›”ë“œ ì„¤ì •
const world = new CANNON.World({ gravity: new CANNON.Vec3(0, -9.82, 0) });
world.broadphase = new CANNON.SAPBroadphase(world);
world.defaultContactMaterial.friction = 0.6;

// 2. ì§€ë©´ ìƒì„±
const groundBody = new CANNON.Body({ mass: 0 });
groundBody.addShape(new CANNON.Plane());
groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
world.addBody(groundBody);

// 3. íŠ¸ë™ íƒ€ì› íŒŒë¼ë¯¸í„°
const trackA = 500;  // x ë°©í–¥ ë°˜ì§€ë¦„
const trackB = 60;   // z ë°©í–¥ ë°˜ì§€ë¦„
const trackWidth = 60;
const numSegments = 400; // íŠ¸ë™ êµ¬ì„± ì •ë°€ë„

// 4. ë°”ë¦¬ì–´ ìƒì„±
const barrierHeight = 1;
const barrierThickness = 1;
const barrierLength = 25;

// Three.js ì¬ì§ˆ ì¬ì‚¬ìš©
const barrierMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
const barrierMeshes = [];

for (let i = 0; i < numSegments; i++) {
  const angle = (i / numSegments) * 2 * Math.PI;

  // ì¤‘ì•™ íƒ€ì› ê²½ë¡œ ì¢Œí‘œ
  const cx = Math.cos(angle);
  const sz = Math.sin(angle);

  const innerX = (trackA - trackWidth / 2) * cx;
  const innerZ = (trackB - trackWidth / 2) * sz;

  const outerX = (trackA + trackWidth / 2) * cx;
  const outerZ = (trackB + trackWidth / 2) * sz;

  // íšŒì „ê°: ì ‘ì„  ë°©í–¥ì„ ë”°ë¼ íšŒì „
  const rotationY = -Math.atan2(
    (trackB * Math.cos(angle)),
    (-trackA * Math.sin(angle))
  );

  // ì™¼ìª½(ì•ˆìª½) ë°”ë¦¬ì–´
  [innerX, innerZ].forEach((_, index) => {
    const isInner = index === 0;
    const x = isInner ? innerX : outerX;
    const z = isInner ? innerZ : outerZ;

    const barrierShape = new CANNON.Box(new CANNON.Vec3(barrierLength / 2, barrierHeight / 2, barrierThickness / 2));
    const barrierBody = new CANNON.Body({ mass: 0 });
    barrierBody.addShape(barrierShape);
    barrierBody.position.set(x, barrierHeight / 3, z);
    barrierBody.quaternion.setFromEuler(0, rotationY, 0);
    world.addBody(barrierBody);

    const barrierGeom = new THREE.BoxGeometry(barrierLength, barrierHeight, barrierThickness);
    const barrierMesh = new THREE.Mesh(barrierGeom, barrierMat);
    barrierMesh.position.copy(barrierBody.position);
    barrierMesh.quaternion.copy(barrierBody.quaternion);
    scene.add(barrierMesh);
    barrierMeshes.push(barrierMesh);
  });
}
    const trackShape = new THREE.Shape();
for (let i = 0; i <= numSegments; i++) {
  const angle = (i / numSegments) * 2 * Math.PI;
  const x = trackA * Math.cos(angle);
  const z = trackB * Math.sin(angle);
  if (i === 0) {
    trackShape.moveTo(x, z);
  } else {
    trackShape.lineTo(x, z);
  }
}
const extrudeSettings = { depth:0.1, bevelEnabled: false };
const geometry = new THREE.ExtrudeGeometry(trackShape, extrudeSettings);
const material = new THREE.MeshStandardMaterial({ color: 0x222222 });
const mesh = new THREE.Mesh(geometry, material);
mesh.rotation.x = -Math.PI / 2;
mesh.position.y = 0;  // â† ì´ ì¤„ ì¶”ê°€
scene.add(mesh);
    
    // ìë™ì°¨ ì°¨ì²´ ë¬¼ë¦¬ 
    // ì°¨ì²´ ë¬¼ë¦¬
  const chassisShape = new CANNON.Box(new CANNON.Vec3(1.5, 0.5, 3));
  const chassisBody = new CANNON.Body({ mass: 110 });
  chassisBody.addShape(chassisShape);
  chassisBody.position.set(500, 0.5, 0);
  chassisBody.angularDamping = 0.5;
  world.addBody(chassisBody);

  // ğŸš— GLTF ìë™ì°¨ ëª¨ë¸ ë¡œë”© (í˜„ëŒ€ ê·¸ëœì € IG)
  // GLTF ëª¨ë¸ ì¶”ê°€ ì „, ë¯¸ë¦¬ ê·¸ë£¹ ìƒì„±
let carMesh = new THREE.Group();
scene.add(carMesh); // ğŸš¨ ì—¬ê¸°ì—ì„œ ë¨¼ì € ì”¬ì— ë„£ê¸°

// ğŸš— GLTF ìë™ì°¨ ëª¨ë¸ ë¡œë”©
const loader = new GLTFLoader();
loader.load(
  '/scene.gltf',
  gltf => {
    const model = scene.gltf;
    model.scale.set(4, 4, 4);
    model.position.set(500, 0.5, 0);
    carMesh.add(model);

    startTimer();
    animate();  // ì •ìƒì ì¼ ë•Œë§Œ í˜¸ì¶œë¨
  },
  undefined,
  error => {
    console.error('âŒ GLTF ë¡œë”© ì‹¤íŒ¨:', error);
    alert('GLTF ë¡œë”© ì‹¤íŒ¨ - ë””ë²„ê¹…ìš© ë”ë¯¸ ëª¨ë¸ë¡œ ëŒ€ì²´ë©ë‹ˆë‹¤.');
    
    // ë””ë²„ê¹…ìš© ë°•ìŠ¤ ìë™ì°¨ë¡œ ëŒ€ì²´ í›„ ì• ë‹ˆë©”ì´ì…˜ ì‹¤í–‰
    const debugCar = new THREE.Mesh(
      new THREE.BoxGeometry(3, 1, 6),
      new THREE.MeshStandardMaterial({ color: 0xff0000 })
    );
    carMesh.add(debugCar);
    
    startTimer();
    animate();
  }
);

    // ì°¨ëŸ‰ìš© RaycastVehicle ì„¤ì •
    const vehicle = new CANNON.RaycastVehicle({
      chassisBody,
      indexRightAxis: 0, // xì¶•ì´ ì°¨ëŸ‰ ì˜¤ë¥¸ìª½
      indexUpAxis: 1,    // yì¶•ì´ ìœ„
      indexForwardAxis: 2, // zì¶•ì´ ì•ìª½
    });

    // íœ  ì˜µì…˜ - ë””ìì¸ ë° ë¬¼ë¦¬ ì¡°ì •
    const wheelOptions = {
      radius: 0.48,
      directionLocal: new CANNON.Vec3(0, -1, 0),
      suspensionStiffness: 45,
      suspensionRestLength: 0.4,
      frictionSlip: 5,
      dampingRelaxation: 2.3,
      dampingCompression: 4.4,
      maxSuspensionForce: 1e4,
      rollInfluence: 0.02,
      axleLocal: new CANNON.Vec3(1, 0, 0),
      maxSuspensionTravel: 0.3,
      useCustomSlidingRotationalSpeed: true,
      customSlidingRotationalSpeed: -30,
    };

    // íœ  ìœ„ì¹˜ ë° ì•ë°”í€´ ì—¬ë¶€ ì„¤ì •
    [[-1.2, 0.2, 2.4, true], [1.2, 0.2, 2.4, true], [-1.2, 0.2, -2.4, false], [1.2, 0.2, -2.4, false]].forEach(
      ([x, y, z, isFront]) => {
        vehicle.addWheel({
          ...wheelOptions,
          chassisConnectionPointLocal: new CANNON.Vec3(x, y, z),
          isFrontWheel: isFront,
        });
      }
    );

    vehicle.addToWorld(world);

    // íœ  ë©”ì‹œ ìƒì„± - ì‹¤ì œ íƒ€ì´ì–´ ëª¨ì–‘ì— ê°€ê¹ê²Œ ë””ìì¸ ë° ê°ë„ ì¡°ì •
    const wheelHolders = [];
    vehicle.wheelInfos.forEach((wheel) => {
      const holder = new THREE.Group();
      scene.add(holder);
      wheelHolders.push(holder);

      const tireGeo = new THREE.CylinderGeometry(wheel.radius, wheel.radius, 0.4, 24);
      const tireMat = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.7, roughness: 0.4 });
      const tireMesh = new THREE.Mesh(tireGeo, tireMat);
      tireMesh.rotation.z = Math.PI / 2; // ëˆ•íˆê¸°
      holder.add(tireMesh);
    });

    // ì¡°ëª… ê°•í™”
    scene.add(new THREE.AmbientLight(0xffffff, 2));
    const light = new THREE.DirectionalLight(0xffffff, 3);
    light.position.set(20, 30, 20);
    scene.add(light);

    // ì…ë ¥ ìƒíƒœ
    const input = { left: false, right: false, accel: false, brake: false };

    // DOM ìš”ì†Œ ë°”ì¸ë”©
    const btnLeft = document.getElementById('btnLeft'),
          btnRight = document.getElementById('btnRight'),
          btnAccel = document.getElementById('btnAccel'),
          btnBrake = document.getElementById('btnBrake'),
          gearDisplay = document.getElementById('gearDisplay'),
          gearButtons = [...document.querySelectorAll('#gearControls button')],
          hud = document.getElementById('hud'),
          timerDisplay = document.getElementById('timerDisplay');

    // ì´ˆê¸° ê¸°ì–´ ìƒíƒœ
    let gearState = 'P';

    // í‚¤ë³´ë“œ ì…ë ¥ ì²˜ë¦¬
    window.addEventListener('keydown', e => {
      switch(e.key.toLowerCase()) {
        case 'arrowleft':
        case 'a': input.left = true; break;
        case 'arrowright':
        case 'd': input.right = true; break;
        case 'arrowup':
        case 'w': input.accel = true; break;
        case 'arrowdown':
        case 's': input.brake = true; break;
        case '1': setGear('P'); break;
        case '2': setGear('R'); break;
        case '3': setGear('N'); break;
        case '4': setGear('D'); break;
      }
    });

    window.addEventListener('keyup', e => {
      switch(e.key.toLowerCase()) {
        case 'arrowleft':
        case 'a': input.left = false; break;
        case 'arrowright':
        case 'd': input.right = false; break;
        case 'arrowup':
        case 'w': input.accel = false; break;
        case 'arrowdown':
        case 's': input.brake = false; break;
      }
    });

    // ëª¨ë°”ì¼ ë²„íŠ¼ ë°”ì¸ë”© í•¨ìˆ˜
    function bindButton(button, prop) {
      const setTrue = e => { e.preventDefault(); input[prop] = true; };
      const setFalse = e => { e.preventDefault(); input[prop] = false; };
      button.addEventListener('mousedown', setTrue);
      button.addEventListener('mouseup', setFalse);
      button.addEventListener('touchstart', setTrue, { passive: false });
      button.addEventListener('touchend', setFalse, { passive: false });
      button.addEventListener('touchcancel', setFalse, { passive: false });
    }

    bindButton(btnLeft, 'left');
    bindButton(btnRight, 'right');
    bindButton(btnAccel, 'accel');
    bindButton(btnBrake, 'brake');

    // ë¸Œë ˆì´í¬ í•¨ìˆ˜
    function applyBrake(force) {
      for(let i=0; i<4; i++) vehicle.setBrake(force, i);
    }

    // ê¸°ì–´ ìƒíƒœì™€ UI ì—…ë°ì´íŠ¸ í•¨ìˆ˜
    const maxEngineForce = 1200;
    const maxBrakeForce = 30;
    const maxSteerVal = Math.PI / 8;
    let engineForce = 0;
    let steeringValue = 0;

    function updateGearDisplay() {
      gearDisplay.textContent = `ê¸°ì–´: ${gearState}`;
      const colorMap = { P: '#00ffff', R: '#ff5555', N: '#ffff55', D: '#55ff55' };
      gearDisplay.style.color = colorMap[gearState] || '#fff';
    }
    function setGear(gear) {
      gearState = gear;
      updateGearDisplay();
    }

    gearButtons.forEach(button => {
      button.addEventListener('click', () => setGear(button.textContent));
    });
    updateGearDisplay();

    // ì°¨ëŸ‰ ì¡°í–¥, ê°€ì†, ë¸Œë ˆì´í¬ ì²˜ë¦¬
    function updateVehicleControls() {
      // ì¡°í–¥: ì¢Œìš° í‚¤ ë˜ëŠ” ë²„íŠ¼ì— ë”°ë¼ steeringValue ì¡°ì ˆ
      const steerSpeed = 0.01;  // ì¡°í–¥ì´ ë³€í™”í•˜ëŠ” ì†ë„ (ë” ì‘ì„ìˆ˜ë¡ ëŠë¦¬ê²Œ ë°˜ì‘)

if (input.left) {
  steeringValue = Math.max(steeringValue - steerSpeed, -maxSteerVal);
} else if (input.right) {
  steeringValue = Math.min(steeringValue + steerSpeed, maxSteerVal);
} else {
  // ì¤‘ë¦½ ë°©í–¥ìœ¼ë¡œ ì²œì²œíˆ ë³µê·€
  if (steeringValue > 0) steeringValue = Math.max(steeringValue - steerSpeed, 0);
  else if (steeringValue < 0) steeringValue = Math.min(steeringValue + steerSpeed, 0);
}

      // ì•ë°”í€´ ì¡°í–¥ì— ì ìš©
      vehicle.setSteeringValue(steeringValue, 0);
      vehicle.setSteeringValue(steeringValue, 1);
      vehicle.setSteeringValue(0, 2); // ë’·ì™¼ìª½ ë°”í€´ â†’ ì¡°í–¥ ì—†ìŒ
      vehicle.setSteeringValue(0, 3); // ë’·ì˜¤ë¥¸ìª½ ë°”í€´ â†’ ì¡°í–¥ ì—†ìŒ
      // ì—”ì§„ í˜ ì´ˆê¸°í™”
      engineForce = 0;

      // ê¸°ì–´ë³„ í˜ ì „ë‹¬
      if (gearState === 'D') {
        if (input.accel) engineForce = maxEngineForce;
        if (input.brake) applyBrake(maxBrakeForce);
        else applyBrake(0);
      } else if (gearState === 'R') {
        if (input.accel) engineForce = -maxEngineForce * 0.6; // í›„ì§„ì€ í˜ ì•½ê°„ ì¤„ì„
        if (input.brake) applyBrake(maxBrakeForce);
        else applyBrake(0);
      } else if (gearState === 'N') {
        applyBrake(input.brake ? maxBrakeForce : 0);
        engineForce = 0;
      } else if (gearState === 'P') {
        applyBrake(maxBrakeForce * 1.5); // ì£¼ì°¨ë¸Œë ˆì´í¬ ê°•í•˜ê²Œ
        engineForce = 0;
      }

      // ì—”ì§„ í˜ ì•ë°”í€´ì— ì ìš© (í›„ë¥œ êµ¬ë™ ê°€ì •)
      vehicle.applyEngineForce(engineForce, 2);
      vehicle.applyEngineForce(engineForce, 3);
    }

    // ì†ë„ ì¸¡ì • (m/s -> km/h)
    function getSpeedKmH() {
      const velocity = chassisBody.velocity;
      return velocity.length() * 3.6;
    }

    // ì¹´ë©”ë¼ ì°¨ëŸ‰ ë’¤ìª½ ìœ„ì¹˜ë¡œ ê³ ì •
    function updateCamera() {
    const relativeCameraOffset = new THREE.Vector3(0, 7, 15);
    const cameraOffset = relativeCameraOffset.applyMatrix4(carMesh.matrixWorld);
    camera.position.lerp(cameraOffset, 0.1);
    camera.lookAt(carMesh.position);
    }

    // íƒ€ì´ë¨¸ ê´€ë¦¬
    let startTime = null;
    let elapsedTime = 0;

    function startTimer() {
      startTime = performance.now();
    }

    function updateTimer() {
      if (startTime === null) return;
      elapsedTime = (performance.now() - startTime) / 1000;
      timerDisplay.textContent = `íƒ€ì´ë¨¸: ${elapsedTime.toFixed(2)} s`;
    }

    // ì• ë‹ˆë©”ì´ì…˜ ë° ë¬¼ë¦¬ ë£¨í”„
  const clock = new THREE.Clock();
    function animate() {
  requestAnimationFrame(animate);
  const delta = clock.getDelta();

  updateVehicleControls();
  world.step(1 / 60, delta, 3);

  // ì°¨ëŸ‰ ìœ„ì¹˜Â·íšŒì „ ë°˜ì˜
  carMesh.position.copy(chassisBody.position);
  carMesh.quaternion.copy(chassisBody.quaternion);

  for (let i = 0; i < vehicle.wheelInfos.length; i++) {
    vehicle.updateWheelTransform(i);
    const t = vehicle.wheelInfos[i].worldTransform;
    wheelHolders[i].position.copy(t.position);
    wheelHolders[i].quaternion.copy(t.quaternion);
  }

  hud.textContent = `ì†ë„: ${getSpeedKmH().toFixed(1)} km/h`;
  updateCamera();
  updateTimer();
  renderer.render(scene, camera);
    }
  </script>
  </body>
</html>
