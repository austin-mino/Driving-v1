<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>완벽한 3D 자동차 게임 – 곡선 차체·언덕·사운드 추가</title>
<style>
  /* ===== 공통 스타일 ===== */
  body {
    margin: 0;
    overflow: hidden;
    background: #121212;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    color: white;
  }
  #rotateWarning {
    position: fixed;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0,0,0,0.85);
    padding: 25px 40px;
    border-radius: 15px;
    font-size: 1.3rem;
    font-weight: bold;
    z-index: 1000;
    display: none;
  }
  #hud, #gearDisplay {
    position: fixed;
    top: 20px;
    background: rgba(0,0,0,0.7);
    padding: 12px 18px;
    border-radius: 10px;
    font-weight: 700;
    font-size: 18px;
    user-select: none;
    z-index: 100;
  }
  #hud { left: 20px; }
  #gearDisplay { right: 20px; }

  #controlsLeft, #controlsRight {
    position: fixed;
    bottom: 20px;
    display: flex;
    gap: 15px;
    z-index: 100;
    user-select: none;
  }
  #controlsLeft { left: 20px; }
  #controlsRight { right: 20px; }

  button.controlBtn {
    padding: 14px 20px;
    border-radius: 12px;
    border: none;
    background: #0078d7;
    color: white;
    font-weight: 700;
    font-size: 16px;
    cursor: pointer;
    touch-action: manipulation;
    user-select: none;
  }
  button.controlBtn:active { background: #005a9e; }

  /* 모바일 최적화 */
  @media (max-width: 600px) {
    button.controlBtn {
      padding: 18px 22px;
      font-size: 20px;
    }
  }
</style>
</head>
<body>

<!-- ===== 시스템 UI ===== -->
<div id="rotateWarning">가로 모드로 전환해주세요</div>
<div id="hud">속도: 0 km/h</div>
<div id="gearDisplay">기어: P</div>

<!-- ===== 모바일 조작 버튼 ===== -->
<div id="controlsLeft">
  <button id="btnLeft" class="controlBtn">◀ 좌</button>
  <button id="btnRight" class="controlBtn">우 ▶</button>
</div>
<div id="controlsRight">
  <button id="btnAccel" class="controlBtn">엑셀</button>
  <button id="btnBrake" class="controlBtn">브레이크</button>
  <button id="btnGear" class="controlBtn">기어 변경</button>
</div>

<script type="module">
/****************************************************
 *  📦 THREE & CANNON IMPORTS                       *
 ***************************************************/
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js';
import { RoundedBoxGeometry } from 'https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/geometries/RoundedBoxGeometry.js';
import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js';

/****************************************************
 *  📐 화면 회전 체크                               *
 ***************************************************/
const rotateWarning = document.getElementById('rotateWarning');
function checkOrientation() {
  rotateWarning.style.display = (window.innerHeight > window.innerWidth) ? 'block' : 'none';
}
window.addEventListener('resize', checkOrientation);
window.addEventListener('orientationchange', checkOrientation);
checkOrientation();

/****************************************************
 *  🎬 THREE.js SCENE                               *
 ***************************************************/
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x222222);

const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 5000);
scene.add(camera);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

/****************************************************
 *  🔊 오디오 설정 (엔진 사운드 & 타이어)            *
 ***************************************************/
const listener = new THREE.AudioListener();
camera.add(listener);

const engineSound = new THREE.Audio(listener);
const tireSound   = new THREE.Audio(listener);
const audioLoader = new THREE.AudioLoader();

// CC0 무료 샘플 URL (네트워크 환경 따라 교체 가능)
const ENGINE_LOOP_URL = 'https://cdn.jsdelivr.net/gh/gordonpn/%40assets/engine_loop.mp3';
const TIRE_SQUEAL_URL = 'https://cdn.jsdelivr.net/gh/gordonpn/%40assets/tire_screech.mp3';

audioLoader.load(ENGINE_LOOP_URL, (buffer) => {
  engineSound.setBuffer(buffer);
  engineSound.setLoop(true);
  engineSound.setVolume(0.4);
  engineSound.setPlaybackRate(0.5);
  engineSound.play();
});

audioLoader.load(TIRE_SQUEAL_URL, (buffer) => {
  tireSound.setBuffer(buffer);
  tireSound.setLoop(false);
  tireSound.setVolume(0.7);
});

function playTireSound() {
  if (!tireSound.isPlaying) tireSound.play();
}

/****************************************************
 *  ⚙️  CANNON-es WORLD                             *
 ***************************************************/
const world = new CANNON.World({ gravity: new CANNON.Vec3(0, -9.82, 0) });
world.broadphase = new CANNON.SAPBroadphase(world);
world.solver.iterations = 20;
world.defaultContactMaterial.friction = 0.8;

/****************************************************
 *  🛣️  지면 & 트랙(언덕 포함)                      *
 ***************************************************/
const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x444444 });

// 기본 평지
const groundShape = new CANNON.Plane();
const groundBody  = new CANNON.Body({ mass: 0, shape: groundShape });
groundBody.quaternion.setFromEuler(-Math.PI/2, 0, 0);
world.addBody(groundBody);

const groundMesh = new THREE.Mesh(new THREE.PlaneGeometry(1000, 1000), groundMaterial);
groundMesh.rotation.x = -Math.PI/2;
scene.add(groundMesh);

// 간단한 언덕(경사) 생성 함수
function createHill({ x=0, z=30, length=30, width=10, height=4, angle=Math.PI/8 }) {
  const halfLength = length/2;
  const halfHeight = height/2;
  const shape = new CANNON.Box(new CANNON.Vec3(width/2, halfHeight, halfLength));
  const body = new CANNON.Body({ mass: 0 });
  body.addShape(shape);
  body.position.set(x, halfHeight, z);
  body.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -angle);
  world.addBody(body);

  const mesh = new THREE.Mesh(new THREE.BoxGeometry(width, height, length), groundMaterial);
  mesh.position.copy(body.position);
  mesh.quaternion.copy(body.quaternion);
  scene.add(mesh);
}

// 메인 트랙 중간에 언덕 하나 추가
createHill({ x: 0, z: 60, length: 40, height: 6, angle: Math.PI/10 });

/****************************************************
 *  🚗 차량 – 곡선형 차체                           *
 ***************************************************/
const chassisSize = { x: 3, y: 1, z: 6 };

// 물리용 박스(보이지 않음)
const chassisShape = new CANNON.Box(new CANNON.Vec3(chassisSize.x/2, chassisSize.y/2, chassisSize.z/2));
const chassisBody  = new CANNON.Body({ mass: 200 });
chassisBody.addShape(chassisShape);
chassisBody.position.set(0, 3, 0);
chassisBody.angularDamping = 0.5;
world.addBody(chassisBody);

// 시각용 – RoundedBoxGeometry로 곡선형 차체 구현
const chassisGeo = new RoundedBoxGeometry(chassisSize.x, chassisSize.y, chassisSize.z, 4, 0.4);
const chassisMat = new THREE.MeshStandardMaterial({ color: 0xff3333, metalness: 0.7, roughness: 0.4 });
const chassisMesh = new THREE.Mesh(chassisGeo, chassisMat);
scene.add(chassisMesh);

/****************************************************
 *  🚙 휠 및 RAYCAST VEHICLE                        *
 ***************************************************/
const vehicle = new CANNON.RaycastVehicle({
  chassisBody,
  indexRightAxis: 0,
  indexUpAxis: 1,
  indexForwardAxis: 2,
});

const wheelOptions = {
  radius: 0.55,
  directionLocal: new CANNON.Vec3(0, -1, 0),
  suspensionStiffness: 30,
  suspensionRestLength: 0.35,
  frictionSlip: 4,
  dampingRelaxation: 2.3,
  dampingCompression: 4.4,
  maxSuspensionForce: 100000,
  rollInfluence: 0.01,
  axleLocal: new CANNON.Vec3(-1, 0, 0),
  maxSuspensionTravel: 0.4,
  customSlidingRotationalSpeed: -30,
  useCustomSlidingRotationalSpeed: true,
};

const wheelPositions = [
  { x: -1.2, z:  2.2, front: true  },
  { x:  1.2, z:  2.2, front: true  },
  { x: -1.2, z: -2.2, front: false },
  { x:  1.2, z: -2.2, front: false },
];

wheelPositions.forEach(({ x, z, front }) => {
  vehicle.addWheel({
    ...wheelOptions,
    chassisConnectionPointLocal: new CANNON.Vec3(x, 0, z),
    isFrontWheel: front,
  });
});
vehicle.addToWorld(world);

// 시각용 휠
const wheelMeshes = [];
vehicle.wheelInfos.forEach((wheel) => {
  const wheelGeo = new THREE.CylinderGeometry(wheel.radius, wheel.radius, 0.4, 24);
  const wheelMat = new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 0.6, roughness: 0.6 });
  const mesh = new THREE.Mesh(wheelGeo, wheelMat);
  mesh.rotation.z = Math.PI / 2;
  scene.add(mesh);
  wheelMeshes.push(mesh);
});

/****************************************************
 *  💡 라이트                                       *
 ***************************************************/
scene.add(new THREE.AmbientLight(0xffffff, 0.5));
const dirLight = new THREE.DirectionalLight(0xffffff, 0.85);
dirLight.position.set(10, 30, 20);
dirLight.castShadow = true;
scene.add(dirLight);

/****************************************************
 *  🔧 HUD & 컨트롤                                 *
 ***************************************************/
const hud         = document.getElementById('hud');
const gearDisplay = document.getElementById('gearDisplay');

const controls = {
  left: false,
  right: false,
  accel: false,
  brake: false,
};

// 모바일 버튼 바인딩 헬퍼
function bindBtn(btn, key) {
  btn.addEventListener('mousedown', () => controls[key] = true);
  btn.addEventListener('mouseup',   () => controls[key] = false);
  btn.addEventListener('touchstart', e => { e.preventDefault(); controls[key] = true; });
  btn.addEventListener('touchend',   e => { e.preventDefault(); controls[key] = false; });
}

bindBtn(document.getElementById('btnLeft'),  'left');
bindBtn(document.getElementById('btnRight'), 'right');
bindBtn(document.getElementById('btnAccel'), 'accel');
bindBtn(document.getElementById('btnBrake'), 'brake');

// 기어 로직
let gearIndex = 0;
const gears = ['P', 'R', 'N', 'D'];
let gearState = gears[gearIndex];

function updateGearDisplay() { gearDisplay.textContent = `기어: ${gearState}`; }
updateGearDisplay();

document.getElementById('btnGear').addEventListener('click', () => {
  gearIndex = (gearIndex + 1) % gears.length;
  gearState = gears[gearIndex];
  updateGearDisplay();
  if (gearState === 'P') {
    applyBrake(1e5);
  }
});

/****************************************************
 *  🚦 주행 파라미터                                *
 ***************************************************/
let engineForce   = 0;
const maxEngine   = 5500;
const maxBrake    = 600;
let brakeForce    = 0;

let steerVal      = 0;            // 현재 핸들 각도
const steerSpeed  = 3;            // 핸들 회전 속도
const maxSteer    = Math.PI / 8;  // 최대 핸들 각도 (~22.5°)

function applyBrake(force) {
  for (let i = 0; i < vehicle.wheelInfos.length; i++) {
    vehicle.setBrake(force, i);
  }
}

/****************************************************
 *  🌀 애니메이션 루프                               *
 ***************************************************/
const clock = new THREE.Clock();

function animate() {
  requestAnimationFrame(animate);
  const dt = clock.getDelta();

  /* ----- 1) 조향값 계산 (좌우 방향 FIX) ----- */
  if (controls.left)  steerVal = Math.max(steerVal - dt * steerSpeed, -maxSteer);
  else if (controls.right) steerVal = Math.min(steerVal + dt * steerSpeed, maxSteer);
  else {
    // 중앙으로 복원
    steerVal = THREE.MathUtils.damp(steerVal, 0, 5, dt);
  }

  vehicle.setSteeringValue(steerVal, 0);
  vehicle.setSteeringValue(steerVal, 1);

  /* ----- 2) 기어별 엔진 & 브레이크 힘 ----- */
  switch (gearState) {
    case 'D':
      engineForce = controls.accel ?  maxEngine : 0;
      brakeForce  = controls.brake ? maxBrake  : 0;
      break;
    case 'R':
      engineForce = controls.accel ? -maxEngine * 0.6 : 0;
      brakeForce  = controls.brake ? maxBrake          : 0;
      break;
    case 'N':
      engineForce = 0;
      brakeForce  = controls.brake ? maxBrake * 0.5    : 0;
      break;
    case 'P':
      engineForce = 0;
      brakeForce  = 1e5;
      break;
  }

  vehicle.applyEngineForce(engineForce, 2);
  vehicle.applyEngineForce(engineForce, 3);
  applyBrake(brakeForce);

  /* ----- 3) 물리 업데이트 ----- */
  world.step(1/60, dt, 8);

  /* ----- 4) 시각 동기화 ----- */
  chassisMesh.position.copy(chassisBody.position);
  chassisMesh.quaternion.copy(chassisBody.quaternion);

  vehicle.wheelInfos.forEach((wheel, i) => {
    vehicle.updateWheelTransform(i);
    wheelMeshes[i].position.copy(wheel.worldTransform.position);
    wheelMeshes[i].quaternion.copy(wheel.worldTransform.quaternion);
  });

  /* ----- 5) 카메라 – 후방 추적 ----- */
  const camOffset = new THREE.Vector3(0, 4, 10).applyQuaternion(chassisMesh.quaternion);
  const desiredPos = chassisMesh.position.clone().add(camOffset);
  camera.position.lerp(desiredPos, 0.08);
  camera.lookAt(chassisMesh.position);

  /* ----- 6) HUD & 사운드 ----- */
  const speedKmh = chassisBody.velocity.length() * 3.6;
  hud.textContent = `속도: ${speedKmh.toFixed(1)} km/h`;

  // 엔진 사운드 RPM 기반 피치
  if (engineSound.isPlaying) {
    const rpm = THREE.MathUtils.clamp(speedKmh / 220, 0, 1);
    engineSound.setPlaybackRate(0.5 + rpm * 1.5);
  }
  // 급제동 시 타이어 소리
  if (controls.brake && speedKmh > 10) playTireSound();

  renderer.render(scene, camera);
}
animate();
</script>

</body>
</html>
