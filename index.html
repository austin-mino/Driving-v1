<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>완벽한 3D 자동차 게임</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #121212;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      color: white;
    }
    #rotateWarning {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.85);
      padding: 25px 40px;
      border-radius: 15px;
      font-size: 1.3rem;
      font-weight: bold;
      z-index: 1000;
      display: none;
    }
    #hud, #gearDisplay {
      position: fixed;
      background: rgba(0,0,0,0.7);
      padding: 12px 18px;
      border-radius: 10px;
      font-weight: 700;
      font-size: 18px;
      user-select: none;
      z-index: 100;
    }
    #hud { top: 20px; left: 20px; }
    #gearDisplay { top: 20px; right: 20px; }
    #controlsLeft, #controlsRight {
      position: fixed;
      bottom: 20px;
      display: flex;
      gap: 15px;
      z-index: 100;
      user-select: none;
    }
    #controlsLeft { left: 20px; }
    #controlsRight { right: 20px; }
    button.controlBtn {
      padding: 14px 20px;
      border-radius: 12px;
      border: none;
      background: #0078d7;
      color: white;
      font-weight: 700;
      font-size: 16px;
      cursor: pointer;
      touch-action: manipulation;
      user-select: none;
    }
    button.controlBtn:active {
      background: #005a9e;
    }
    @media (max-width: 600px) {
      button.controlBtn {
        padding: 18px 22px;
        font-size: 20px;
      }
    }
  </style>
</head>
<body>
  <div id="rotateWarning">가로 모드로 전환해주세요</div>
  <div id="hud">속도: 0 km/h</div>
  <div id="gearDisplay">기어: P</div>
  <div id="controlsLeft">
    <button id="btnLeft" class="controlBtn">◀ 좌</button>
    <button id="btnRight" class="controlBtn">우 ▶</button>
  </div>
  <div id="controlsRight">
    <button id="btnAccel" class="controlBtn">엑셀</button>
    <button id="btnBrake" class="controlBtn">브레이크</button>
    <button id="btnGear" class="controlBtn">기어 변경</button>
  </div>
  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js';
    import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js';
// === 자동차 물리 및 시각화 구성 ===
const chassisWidth = 3;
const chassisHeight = 1;
const chassisDepth = 6;

const chassisShape = new CANNON.Box(new CANNON.Vec3(chassisWidth/2, chassisHeight/2, chassisDepth/2));
const chassisBody = new CANNON.Body({ mass: 200 });
chassisBody.addShape(chassisShape);
chassisBody.position.set(0, 2, 0);
chassisBody.angularDamping = 0.5;
world.addBody(chassisBody);

// 기본 chassisMesh (후에 실제 자동차처럼 모델링할 때 대체 예정)
const chassisMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000, metalness: 0.7, roughness: 0.4 });
const chassisMesh = new THREE.Mesh(new THREE.BoxGeometry(chassisWidth, chassisHeight, chassisDepth), chassisMaterial);
scene.add(chassisMesh);

// RaycastVehicle 생성
const vehicle = new CANNON.RaycastVehicle({
  chassisBody,
  indexRightAxis: 0,
  indexUpAxis: 1,
  indexForwardAxis: 2,
});

// 휠 설정
const wheelOptions = {
  radius: 0.5,
  directionLocal: new CANNON.Vec3(0, -1, 0),
  suspensionStiffness: 30,
  suspensionRestLength: 0.3,
  frictionSlip: 5,
  dampingRelaxation: 2.3,
  dampingCompression: 4.4,
  maxSuspensionForce: 100000,
  rollInfluence: 0.01,
  axleLocal: new CANNON.Vec3(-1, 0, 0),
  maxSuspensionTravel: 0.3,
  useCustomSlidingRotationalSpeed: true,
  customSlidingRotationalSpeed: -30,
};

// 바퀴 위치 설정 (조향 포함)
vehicle.addWheel({
  ...wheelOptions,
  chassisConnectionPointLocal: new CANNON.Vec3(-1.2, 0, 2.4),
  isFrontWheel: true,
});
vehicle.addWheel({
  ...wheelOptions,
  chassisConnectionPointLocal: new CANNON.Vec3(1.2, 0, 2.4),
  isFrontWheel: true,
});
vehicle.addWheel({
  ...wheelOptions,
  chassisConnectionPointLocal: new CANNON.Vec3(-1.2, 0, -2.4),
  isFrontWheel: false,
});
vehicle.addWheel({
  ...wheelOptions,
  chassisConnectionPointLocal: new CANNON.Vec3(1.2, 0, -2.4),
  isFrontWheel: false,
});

vehicle.addToWorld(world);

// 휠 메쉬 시각화
const wheelMeshes = [];
vehicle.wheelInfos.forEach(wheel => {
  const wheelGeo = new THREE.CylinderGeometry(wheel.radius, wheel.radius, 0.4, 32);
  const wheelMat = new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 0.7, roughness: 0.5 });
  const wheelMesh = new THREE.Mesh(wheelGeo, wheelMat);
  wheelMesh.rotation.z = Math.PI / 2;
  scene.add(wheelMesh);
  wheelMeshes.push(wheelMesh);
});
    // === 조명 설정 ===
const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
scene.add(ambientLight);

const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
directionalLight.position.set(10, 30, 20);
directionalLight.castShadow = true;
scene.add(directionalLight);

// === 주행 상태 변수 ===
let engineForce = 0;
const maxEngineForce = 5000;
const maxBrakeForce = 400;
let brakeForce = 0;

let steeringValue = 0;
const maxSteerVal = Math.PI / 8; // 약 22.5도

// === 기어 상태 ===
let gearState = 'P'; // P, R, N, D
const gears = ['P', 'R', 'N', 'D'];
let gearIndex = 0;

function updateGearDisplay() {
  gearDisplay.textContent = `기어: ${gearState}`;
}
updateGearDisplay();

// === 입력 상태 ===
const input = {
  left: false,
  right: false,
  accel: false,
  brake: false,
};

// === 버튼 입력 이벤트 처리 ===
function bindBtnEvents(button, prop) {
  button.addEventListener('mousedown', () => { input[prop] = true; });
  button.addEventListener('mouseup', () => { input[prop] = false; });
  button.addEventListener('touchstart', e => { e.preventDefault(); input[prop] = true; });
  button.addEventListener('touchend', e => { e.preventDefault(); input[prop] = false; });
}

bindBtnEvents(btnLeft, 'left');
bindBtnEvents(btnRight, 'right');
bindBtnEvents(btnAccel, 'accel');
bindBtnEvents(btnBrake, 'brake');

// === 기어 변경 이벤트 ===
btnGear.addEventListener('click', () => {
  gearIndex = (gearIndex + 1) % gears.length;
  gearState = gears[gearIndex];
  updateGearDisplay();

  if (gearState === 'P') {
    applyBrake(1e5); // 주차 브레이크
    engineForce = 0;
  } else if (gearState === 'N') {
    engineForce = 0;
    brakeForce = 0;
  }
});

// === 브레이크 적용 함수 ===
function applyBrake(force) {
  for (let i = 0; i < 4; i++) {
    vehicle.setBrake(force, i);
  }
}
    // === 자동차 차체 모델링과 휠 메쉬 위치 동기화 ===
function syncWheelMeshes() {
  for (let i = 0; i < vehicle.wheelInfos.length; i++) {
    vehicle.updateWheelTransform(i);
    const t = vehicle.wheelInfos[i].worldTransform;
    wheelMeshes[i].position.copy(t.position);
    wheelMeshes[i].quaternion.copy(t.quaternion);
  }
}

function syncCarModel() {
  chassisMesh.position.copy(chassisBody.position);
  chassisMesh.quaternion.copy(chassisBody.quaternion);

  if (roundedCarBody) {
    roundedCarBody.position.copy(chassisBody.position);
    roundedCarBody.quaternion.copy(chassisBody.quaternion);
  }
}

// === 애니메이션 루프 ===
const clock = new THREE.Clock();

function animate() {
  requestAnimationFrame(animate);

  const dt = clock.getDelta();

  // 조향 입력 처리
  if (input.left) {
    steeringValue = Math.min(steeringValue + dt * 3, maxSteerVal);
  } else if (input.right) {
    steeringValue = Math.max(steeringValue - dt * 3, -maxSteerVal);
  } else {
    if (steeringValue > 0) steeringValue = Math.max(0, steeringValue - dt * 5);
    else steeringValue = Math.min(0, steeringValue + dt * 5);
  }

  vehicle.setSteeringValue(steeringValue, 0);
  vehicle.setSteeringValue(steeringValue, 1);

  // 기어 상태에 따른 힘 적용
  if (gearState === 'D') {
    engineForce = input.accel ? maxEngineForce : 0;
    brakeForce = input.brake ? maxBrakeForce : 0;
  } else if (gearState === 'R') {
    engineForce = input.accel ? -maxEngineForce / 2 : 0;
    brakeForce = input.brake ? maxBrakeForce : 0;
  } else if (gearState === 'N') {
    engineForce = 0;
    brakeForce = input.brake ? maxBrakeForce / 2 : 0;
  } else if (gearState === 'P') {
    engineForce = 0;
    brakeForce = 1e5;
  }

  vehicle.applyEngineForce(engineForce, 2);
  vehicle.applyEngineForce(engineForce, 3);
  applyBrake(brakeForce);

  // 물리 시뮬레이션 진행
  world.step(1 / 60, dt, 10);

  // 모델 및 휠 위치 동기화
  syncCarModel();
  syncWheelMeshes();

  // 장애물 위치 동기화
  obstacles.forEach(({ body, mesh }) => {
    mesh.position.copy(body.position);
    mesh.quaternion.copy(body.quaternion);
  });

  // 카메라: 진행방향 뒤에서 차량 바라보기
  const forward = new THREE.Vector3(0, 0, 1).applyQuaternion(chassisBody.quaternion).normalize();
  const camDistance = 10;
  const camHeight = 4;
  const camPosition = chassisBody.position.clone().addScaledVector(forward, -camDistance);
  camPosition.y += camHeight;

  camera.position.lerp(camPosition, 0.1);
  camera.lookAt(chassisBody.position);

  // 속도 계산 및 HUD 표시 (m/s -> km/h)
  const speedKmh = chassisBody.velocity.length() * 3.6;
  hud.textContent = `속도: ${speedKmh.toFixed(1)} km/h`;

  // 렌더링
  renderer.render(scene, camera);
}

animate();
    
  </script>
</body>
</html>
