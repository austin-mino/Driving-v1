<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>3D driving</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #121212;
      font-family: 'Segoe UI', Tahoma, Verdana, sans-serif;
      color: #fff;
      user-select: none;
    }
    #rotateWarning {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.85);
      padding: 25px 40px;
      border-radius: 15px;
      font-size: 1.3rem;
      font-weight: bold;
      z-index: 1000;
      display: none;
    }
    #hud, #gearDisplay, #timerDisplay {
      position: fixed;
      background: rgba(0, 0, 0, 0.7);
      padding: 12px 18px;
      border-radius: 10px;
      font-weight: 700;
      font-size: 18px;
      user-select: none;
      z-index: 100;
    }
    #hud { top: 20px; left: 20px; }
    #gearDisplay { top: 10px; right: 20px; }
    #timerDisplay { top: 60px; left: 20px; }
    #gearControls {
      position: fixed;
      top: 100px;
      right: 20px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      z-index: 100;
    }
    #controlsLeft, #driveControls {
      position: fixed;
      bottom: 20px;
      display: flex;
      gap: 15px;
      z-index: 100;
      user-select: none;
    }
    #controlsLeft { left: 20px; }
    #driveControls { right: 20px; }

    button.controlBtn {
      padding: 14px 20px;
      border-radius: 12px;
      border: none;
      background: #0078d7;
      color: #fff;
      font-weight: 700;
      font-size: 16px;
      cursor: pointer;
      touch-action: manipulation;
      transition: background-color 0.2s, color 0.2s;
      user-select: none;
    }
    button.controlBtn:active {
      background: #005a9e;
    }
    @media (max-width: 600px) {
      button.controlBtn {
        padding: 18px 22px;
        font-size: 20px;
      }
    }
    /* 카메라 모드 토글 버튼 스타일 */
    #cameraToggleBtn {
      position: fixed;
      top: 140px;
      right: 20px;
      background: rgba(0, 120, 215, 0.7);
      padding: 8px 12px;
      border-radius: 10px;
      font-weight: 700;
      font-size: 14px;
      cursor: pointer;
      z-index: 150;
      user-select: none;
      transition: background-color 0.3s;
    }
    #cameraToggleBtn:hover {
      background: rgba(0, 120, 215, 1);
    }
  </style>
</head>
<body>
  <div id="rotateWarning">가로 모드로 전환해주세요</div>
  <div id="hud">속도: 0 km/h</div>
  <div id="timerDisplay">타이머: 0.00 s</div>
  <div id="gearDisplay">기어: P</div>

  <!-- 좌/우 스티어링 -->
  <div id="controlsLeft">
    <button id="btnLeft" class="controlBtn">◀ 좌</button>
    <button id="btnRight" class="controlBtn">우 ▶</button>
  </div>
  <!-- 엑셀·브레이크 -->
  <div id="driveControls">
    <button id="btnAccel" class="controlBtn">엑셀</button>
    <button id="btnBrake" class="controlBtn">브레이크</button>
  </div>

  <!-- 차량 리셋 -->
  <div id="reset" style="position: fixed; bottom: 90px; right: 20px; z-index: 100;">
    <button id="btnReset" class="controlBtn">차량 리셋</button>
  </div>

  <!-- 기어 선택 -->
  <div id="gearControls">
    <button id="gearP" class="controlBtn">P</button>
    <button id="gearR" class="controlBtn">R</button>
    <button id="gearN" class="controlBtn">N</button>
    <button id="gearD" class="controlBtn">D</button>
  </div>

  <!-- 카메라 모드 토글 버튼 -->
  <div id="cameraToggleBtn">카메라 모드: 뒤쪽</div>

  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js';
    import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js';

    // --- 가로모드 체크 ---
    const rotateWarning = document.getElementById('rotateWarning');
    function checkOrientation() {
      rotateWarning.style.display = window.innerHeight > window.innerWidth ? 'block' : 'none';
    }
    window.addEventListener('resize', checkOrientation);
    window.addEventListener('orientationchange', checkOrientation);
    checkOrientation();

    // --- 기본 변수 및 상태 ---
    let isDragging = false;
    let previousMousePosition = { x: 0, y: 0 };
    let yaw = 0;
    let pitch = 0.15; // 약간 위를 보는 초기값
    const sensitivity = 0.005;

    // --- 마우스 드래그로 카메라 회전 (자유 모드용) ---
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    renderer.domElement.addEventListener('mousedown', (event) => {
      if (event.button === 0 && cameraFollow === false) {
        isDragging = true;
        previousMousePosition.x = event.clientX;
        previousMousePosition.y = event.clientY;
      }
    });
    renderer.domElement.addEventListener('mouseup', (event) => {
      if (event.button === 0) {
        isDragging = false;
      }
    });
    renderer.domElement.addEventListener('mousemove', (event) => {
      if (!isDragging) return;
      if(cameraFollow === false) {
        const deltaMove = {
          x: event.clientX - previousMousePosition.x,
          y: event.clientY - previousMousePosition.y
        };

        yaw -= deltaMove.x * sensitivity;
        pitch -= deltaMove.y * sensitivity;

        const pitchLimit = Math.PI / 3;
        pitch = Math.max(-pitchLimit, Math.min(pitchLimit, pitch));

        previousMousePosition.x = event.clientX;
        previousMousePosition.y = event.clientY;
      }
    });

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // --- 씬 및 카메라 ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x222222);
    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.05, 5000);
    camera.position.set(0, 5, 15);
    camera.lookAt(0, 0, 0);

    // --- 카메라 모드 플래그 및 버튼 ---
    let cameraFollow = true; // 기본은 자동차 뒤쪽 따라가는 모드
    const cameraToggleBtn = document.getElementById('cameraToggleBtn');
    cameraToggleBtn.addEventListener('click', () => {
      cameraFollow = !cameraFollow;
      cameraToggleBtn.textContent = `카메라 모드: ${cameraFollow ? '뒤쪽' : '자유'}`;
    });

    // --- Cannon.js 물리 세계 설정 ---
    const world = new CANNON.World({ gravity: new CANNON.Vec3(0, -9.82, 0) });
    world.broadphase = new CANNON.SAPBroadphase(world);
    world.defaultContactMaterial.friction = 0.6;

    // --- 지면 생성 ---
    const groundBody = new CANNON.Body({ mass: 0 });
    groundBody.addShape(new CANNON.Plane());
    groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
    world.addBody(groundBody);

    // --- 트랙 파라미터 ---
    const trackA = 500;
    const trackB = 60;
    const trackWidth = 60;
    const numSegments = 400;

    // --- 바리어 및 트랙 생성 (생략: 이전 코드 동일) ---
    // ... (필요시 알려주시면 바리어 생성 코드도 통합 제공 가능) ...

    // --- 트랙 바닥 메쉬 ---
    const trackShape = new THREE.Shape();
    for (let i = 0; i <= numSegments; i++) {
      const angle = (i / numSegments) * 2 * Math.PI;
      const x = trackA * Math.cos(angle);
      const z = trackB * Math.sin(angle);
      if (i === 0) trackShape.moveTo(x, z);
      else trackShape.lineTo(x, z);
    }
    trackShape.closePath();
    const extrudeSettings = { depth: trackWidth, bevelEnabled: false };
    const trackGeometry = new THREE.ExtrudeGeometry(trackShape, extrudeSettings);
    trackGeometry.rotateX(-Math.PI / 2);
    trackGeometry.translate(0, 0, -trackWidth / 2);
    const trackMaterial = new THREE.MeshStandardMaterial({ color: 0x222222 });
    const trackMesh = new THREE.Mesh(trackGeometry, trackMaterial);
    scene.add(trackMesh);

    // --- 조명 ---
    scene.add(new THREE.AmbientLight(0x555555));
    const dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(10, 20, 15);
    scene.add(dirLight);

    // --- 차체 모델 함수 (크기 및 위치 수정) ---
    function createGrandeurIGCarDetailed() {
      const car = new THREE.Group();

      // 차체 기본
      const bodyMat = new THREE.MeshStandardMaterial({ color: 0x0b3b7c, metalness: 0.4, roughness: 0.3 });

      // 차체 메인 박스 (길이, 높이, 폭)
      const mainBodyGeom = new THREE.BoxGeometry(5.4, 1.4, 2.1);
      const mainBodyMesh = new THREE.Mesh(mainBodyGeom, bodyMat);
      mainBodyMesh.position.set(0, 0.8, 0);
      car.add(mainBodyMesh);

      // 보닛 (앞부분)
      const bonnetGeom = new THREE.BoxGeometry(1.2, 0.5, 2.1);
      const bonnetMesh = new THREE.Mesh(bonnetGeom, bodyMat);
      bonnetMesh.position.set(3.3, 1.2, 0);
      car.add(bonnetMesh);

      // 트렁크 (뒷부분)
      const trunkGeom = new THREE.BoxGeometry(1.4, 0.5, 2.1);
      const trunkMesh = new THREE.Mesh(trunkGeom, bodyMat);
      trunkMesh.position.set(-3.2, 1.2, 0);
      car.add(trunkMesh);

      // 창문
      const windowMat = new THREE.MeshStandardMaterial({ color: 0x6ea1c7, metalness: 0.1, roughness: 0.1, transparent: true, opacity: 0.7 });
      const windowGeom = new THREE.BoxGeometry(4.2, 0.8, 1.8);
      const windowMesh = new THREE.Mesh(windowGeom, windowMat);
      windowMesh.position.set(0, 1.6, 0);
      car.add(windowMesh);

      // 바퀴는 따로 추가 (RaycastVehicle에서 처리)

      return car;
    }

    // --- 휠 메쉬 생성 함수 ---
    function createWheel() {
      const wheelGroup = new THREE.Group();

      const tireMat = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.5, roughness: 0.7 });
      const tireGeom = new THREE.CylinderGeometry(0.5, 0.5, 0.3, 32);
      const tireMesh = new THREE.Mesh(tireGeom, tireMat);
      tireMesh.rotation.z = Math.PI / 2;
      wheelGroup.add(tireMesh);

      const rimMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, metalness: 1, roughness: 0.25 });
      const rimGeom = new THREE.CylinderGeometry(0.35, 0.35, 0.15, 16);
      const rimMesh = new THREE.Mesh(rimGeom, rimMat);
      rimMesh.rotation.z = Math.PI / 2;
      wheelGroup.add(rimMesh);

      return wheelGroup;
    }

    // --- 차체 물리 바디 ---
    const chassisShape = new CANNON.Box(new CANNON.Vec3(2.7, 0.7, 1.05)); // half extents
    const chassisBody = new CANNON.Body({ mass: 1500 });
    chassisBody.addShape(chassisShape);
    chassisBody.position.set(0, 0.7, 0);
    chassisBody.angularDamping = 0.4;
    world.addBody(chassisBody);

    // --- 차체 3D 모델 ---
    const carModel = createGrandeurIGCarDetailed();
    scene.add(carModel);

    // --- RaycastVehicle 생성 ---
    const vehicleOptions = {
      chassisBody: chassisBody,
      indexRightAxis: 0,
      indexUpAxis: 1,
      indexForwardAxis: 2,
    };
    const vehicle = new CANNON.RaycastVehicle(vehicleOptions);

    // 휠 옵션 (반지름 0.5로 통일)
    const wheelOptions = {
      radius: 0.5,
      directionLocal: new CANNON.Vec3(0, -1, 0),
      suspensionStiffness: 40,
      suspensionRestLength: 0.3,
      frictionSlip: 3,
      dampingRelaxation: 2.3,
      dampingCompression: 4.4,
      maxSuspensionForce: 100000,
      rollInfluence: 0.01,
      axleLocal: new CANNON.Vec3(-1, 0, 0),
      chassisConnectionPointLocal: new CANNON.Vec3(),
      maxSuspensionTravel: 0.3,
      customSlidingRotationalSpeed: -30,
      useCustomSlidingRotationalSpeed: true,
    };

    // 휠 위치 배열
    const wheelPositions = [
      new CANNON.Vec3(-2.3, 0, -4), // 앞 왼쪽
      new CANNON.Vec3(2.3, 0, -4),  // 앞 오른쪽
      new CANNON.Vec3(-2.3, 0, 4),  // 뒤 왼쪽
      new CANNON.Vec3(2.3, 0, 4),   // 뒤 오른쪽
    ];

    // 휠 Mesh 배열
    const wheelHolders = [];

    for (let i = 0; i < wheelPositions.length; i++) {
      wheelOptions.chassisConnectionPointLocal.copy(wheelPositions[i]);
      vehicle.addWheel(wheelOptions);

      const wheelMesh = createWheel();
      scene.add(wheelMesh);
      wheelHolders.push(wheelMesh);
    }

    vehicle.addToWorld(world);

    // --- 차량 컨트롤 변수 ---
    let engineForce = 0;
    let maxEngineForce = 2500;
    let maxBrakeForce = 100;

    // --- 기어 상태 ---
    const gearDisplay = document.getElementById('gearDisplay');
    let currentGear = 'P'; // P, R, N, D

    // --- 속도 계산 ---
    function getSpeedKmH() {
      return chassisBody.velocity.length() * 3.6;
    }

    // --- 차량 리셋 함수 ---
    function resetCar() {
      chassisBody.position.set(0, 0.7, 0);
      chassisBody.velocity.setZero();
      chassisBody.angularVelocity.setZero();
      chassisBody.quaternion.set(0, 0, 0, 1);
    }

    // --- UI 요소 ---
    const btnLeft = document.getElementById('btnLeft');
    const btnRight = document.getElementById('btnRight');
    const btnAccel = document.getElementById('btnAccel');
    const btnBrake = document.getElementById('btnBrake');
    const btnReset = document.getElementById('btnReset');
    const gearP = document.getElementById('gearP');
    const gearR = document.getElementById('gearR');
    const gearN = document.getElementById('gearN');
    const gearD = document.getElementById('gearD');

    // --- 조작 상태 변수 ---
    let steerValue = 0;
    let accelPressed = false;
    let brakePressed = false;
    let steerLeftPressed = false;
    let steerRightPressed = false;

    // --- 조작 이벤트 핸들러 ---
    btnLeft.addEventListener('pointerdown', () => { steerLeftPressed = true; });
    btnLeft.addEventListener('pointerup', () => { steerLeftPressed = false; });
    btnRight.addEventListener('pointerdown', () => { steerRightPressed = true; });
    btnRight.addEventListener('pointerup', () => { steerRightPressed = false; });
    btnAccel.addEventListener('pointerdown', () => { accelPressed = true; });
    btnAccel.addEventListener('pointerup', () => { accelPressed = false; });
    btnBrake.addEventListener('pointerdown', () => { brakePressed = true; });
    btnBrake.addEventListener('pointerup', () => { brakePressed = false; });
    btnReset.addEventListener('click', resetCar);

    // 기어 변경
    function setGear(gear) {
      currentGear = gear;
      gearDisplay.textContent = '기어: ' + gear;
      engineForce = 0;
      vehicle.setBrake(0, 0);
      vehicle.setBrake(0, 1);
      vehicle.setBrake(0, 2);
      vehicle.setBrake(0, 3);
    }
    gearP.addEventListener('click', () => setGear('P'));
    gearR.addEventListener('click', () => setGear('R'));
    gearN.addEventListener('click', () => setGear('N'));
    gearD.addEventListener('click', () => setGear('D'));

    // --- 메인 애니메이션 루프 ---
    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);

      const delta = clock.getDelta();

      // 차량 조작 업데이트
      steerValue = 0;
      if (steerLeftPressed) steerValue = 0.5;
      else if (steerRightPressed) steerValue = -0.5;

      // 스티어링 적용 (앞 바퀴 두 개)
      vehicle.setSteeringValue(steerValue, 0);
      vehicle.setSteeringValue(steerValue, 1);

      // 엔진 및 브레이크 적용
      if (currentGear === 'P' || currentGear === 'N') {
        // 주행 금지
        engineForce = 0;
        vehicle.setBrake(maxBrakeForce, 0);
        vehicle.setBrake(maxBrakeForce, 1);
        vehicle.setBrake(maxBrakeForce, 2);
        vehicle.setBrake(maxBrakeForce, 3);
      } else {
        vehicle.setBrake(0, 0);
        vehicle.setBrake(0, 1);
        vehicle.setBrake(0, 2);
        vehicle.setBrake(0, 3);

        if (accelPressed) {
          engineForce = maxEngineForce;
        } else {
          engineForce = 0;
        }
        if (brakePressed) {
          vehicle.setBrake(maxBrakeForce, 0);
          vehicle.setBrake(maxBrakeForce, 1);
          vehicle.setBrake(maxBrakeForce, 2);
          vehicle.setBrake(maxBrakeForce, 3);
        }
      }

      // 전진/후진 처리
      let appliedForce = 0;
      if (currentGear === 'D') appliedForce = engineForce;
      else if (currentGear === 'R') appliedForce = -engineForce;
      else appliedForce = 0;

      vehicle.applyEngineForce(appliedForce, 2);
      vehicle.applyEngineForce(appliedForce, 3);

      // 물리 스텝
      world.step(1 / 60, delta, 3);

      // 차량 3D 모델 위치 및 회전 동기화
      carModel.position.copy(chassisBody.position);
      carModel.quaternion.copy(chassisBody.quaternion);

      // 휠 위치 및 회전 업데이트
      for (let i = 0; i < vehicle.wheelInfos.length; i++) {
        vehicle.updateWheelTransform(i);
        const t = vehicle.wheelInfos[i].worldTransform;
        wheelHolders[i].position.copy(t.position);
        wheelHolders[i].quaternion.copy(t.quaternion);
      }

      // 속도 HUD 업데이트
      const speedKmH = getSpeedKmH();
      document.getElementById('hud').textContent = `속도: ${speedKmH.toFixed(1)} km/h`;

      // 카메라 위치 업데이트
      updateCamera();

      renderer.render(scene, camera);
    }

    // --- 카메라 업데이트 함수 ---
    function updateCamera() {
      if (cameraFollow) {
        // 차체 뒤쪽에서 따라가는 카메라
        const relativeCameraOffset = new THREE.Vector3(0, 4, 10); // 뒤쪽 약간 위
        const cameraOffset = relativeCameraOffset.applyQuaternion(carModel.quaternion).add(carModel.position);
        camera.position.lerp(cameraOffset, 0.1);

        const lookAtPos = new THREE.Vector3();
        lookAtPos.copy(carModel.position);
        lookAtPos.y += 1.5; // 약간 위를 봄
        camera.lookAt(lookAtPos);
      } else {
        // 자유 시점: yaw, pitch로 카메라 위치 조정
        const radius = 15;
        const offset = new THREE.Vector3();
        offset.x = radius * Math.sin(yaw) * Math.cos(pitch);
        offset.y = radius * Math.sin(pitch) + 5;
        offset.z = radius * Math.cos(yaw) * Math.cos(pitch);
        camera.position.copy(carModel.position).add(offset);
        camera.lookAt(carModel.position);
      }
    }

    // --- 시작 ---
    resetCar();
    animate();

  </script>
</body>
</html>

