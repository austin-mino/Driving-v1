<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>3D 자동차 게임 – 원형 트랙</title>
<style>
  body {
    margin: 0; overflow: hidden;
    background: #121212;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    color: white;
  }
  #rotateWarning {
    position: fixed; top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0,0,0,0.85);
    padding: 25px 40px;
    border-radius: 15px;
    font-size: 1.3rem;
    font-weight: bold;
    z-index: 1000;
    display: none;
  }
  #hud, #gearDisplay {
    position: fixed;
    background: rgba(0,0,0,0.7);
    padding: 12px 18px;
    border-radius: 10px;
    font-weight: 700;
    font-size: 18px;
    user-select: none;
    z-index: 100;
  }
  #hud {
    top: 20px; left: 20px;
  }
  #gearDisplay {
    top: 20px; right: 20px;
  }
  #controlsLeft, #driveControls {
    position: fixed;
    bottom: 20px;
    display: flex;
    gap: 15px;
    z-index: 100;
    user-select: none;
  }
  #controlsLeft {
    left: 20px;
  }
  #driveControls {
    right: 20px;
  }
  button.controlBtn {
    padding: 14px 22px;
    border-radius: 12px;
    border: none;
    background: #0078d7;
    color: white;
    font-weight: 700;
    font-size: 16px;
    cursor: pointer;
    touch-action: manipulation;
  }
  button.controlBtn:active {
    background: #005a9e;
  }
  @media (max-width: 600px) {
    button.controlBtn {
      padding: 18px 24px;
      font-size: 20px;
    }
  }
</style>
</head>
<body>

<div id="rotateWarning">가로 모드로 전환해주세요</div>

<div id="hud">속도: 0 km/h</div>
<div id="gearDisplay">기어: P</div>

<div id="controlsLeft">
  <button id="btnLeft" class="controlBtn">◀ 좌</button>
  <button id="btnRight" class="controlBtn">우 ▶</button>
</div>

<div id="driveControls">
  <button id="btnAccel" class="controlBtn">엑셀</button>
  <button id="btnBrake" class="controlBtn">브레이크</button>
  <button id="btnGear" class="controlBtn">기어 변경</button>
</div>

<script type="module">
//--- Import three.js and cannon-es ---
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js';
import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js';

// DOM elements
const rotateWarning = document.getElementById('rotateWarning');
const hud = document.getElementById('hud');
const gearDisplay = document.getElementById('gearDisplay');
const btnLeft = document.getElementById('btnLeft');
const btnRight = document.getElementById('btnRight');
const btnAccel = document.getElementById('btnAccel');
const btnBrake = document.getElementById('btnBrake');
const btnGear = document.getElementById('btnGear');

// Screen orientation check
function checkOrientation() {
  rotateWarning.style.display = (window.innerHeight > window.innerWidth) ? 'block' : 'none';
}
window.addEventListener('resize', checkOrientation);
window.addEventListener('orientationchange', checkOrientation);
checkOrientation();

// THREE.js scene setup
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x222222);

const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 5000);
camera.position.set(0, 5, -15);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setClearColor(0x222222);
document.body.appendChild(renderer.domElement);

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

// CANNON physics setup
const world = new CANNON.World({
  gravity: new CANNON.Vec3(0, -9.82, 0),
});
world.broadphase = new CANNON.SAPBroadphase(world);
world.solver.iterations = 20;
world.defaultContactMaterial.friction = 0.6;

// Ground
const groundShape = new CANNON.Plane();
const groundBody = new CANNON.Body({ mass: 0, shape: groundShape });
groundBody.quaternion.setFromEuler(-Math.PI/2, 0, 0);
world.addBody(groundBody);

const groundMaterial = new THREE.MeshStandardMaterial({color: 0x444444});
const groundMesh = new THREE.Mesh(new THREE.PlaneGeometry(1000,1000), groundMaterial);
groundMesh.rotation.x = -Math.PI/2;
scene.add(groundMesh);

// --- 원형 트랙 생성 ---
const trackRadius = 80;
const trackWidth = 8;
const trackHeight = 2;

// 트랙 바닥 원형 (바닥으로 씀)
const trackFloorGeom = new THREE.RingGeometry(trackRadius, trackRadius + trackWidth, 128);
const trackFloorMat = new THREE.MeshStandardMaterial({color: 0x555555, side: THREE.DoubleSide});
const trackFloor = new THREE.Mesh(trackFloorGeom, trackFloorMat);
trackFloor.rotation.x = -Math.PI/2;
scene.add(trackFloor);

// 트랙 울타리(좌우 경계) 박스 충돌체 및 시각화
const fenceHeight = 2;
const fenceThickness = 0.3;
const fenceMaterial = new THREE.MeshStandardMaterial({color: 0x880000});

for(let i=0; i<360; i+=5){
  const rad = THREE.MathUtils.degToRad(i);

  // 왼쪽 울타리 시각화
  const fenceGeomL = new THREE.BoxGeometry(fenceThickness, fenceHeight, trackWidth);
  const fenceL = new THREE.Mesh(fenceGeomL, fenceMaterial);
  fenceL.position.set(Math.cos(rad)*(trackRadius - fenceThickness/2), fenceHeight/2, Math.sin(rad)*(trackRadius - fenceThickness/2));
  fenceL.lookAt(0, fenceHeight/2, 0);
  scene.add(fenceL);

  // 오른쪽 울타리 시각화
  const fenceGeomR = new THREE.BoxGeometry(fenceThickness, fenceHeight, trackWidth);
  const fenceR = new THREE.Mesh(fenceGeomR, fenceMaterial);
  fenceR.position.set(Math.cos(rad)*(trackRadius + trackWidth + fenceThickness/2), fenceHeight/2, Math.sin(rad)*(trackRadius + trackWidth + fenceThickness/2));
  fenceR.lookAt(0, fenceHeight/2, 0);
  scene.add(fenceR);

  // 충돌용 장애물 바디 (left)
  const boxShapeL = new CANNON.Box(new CANNON.Vec3(fenceThickness/2, fenceHeight/2, trackWidth/2));
  const boxBodyL = new CANNON.Body({mass: 0, shape: boxShapeL});
  boxBodyL.position.set(Math.cos(rad)*(trackRadius - fenceThickness/2), fenceHeight/2, Math.sin(rad)*(trackRadius - fenceThickness/2));
  boxBodyL.quaternion.copy(new CANNON.Quaternion().setFromEuler(0, -rad, 0));
  world.addBody(boxBodyL);

  // 충돌용 장애물 바디 (right)
  const boxShapeR = new CANNON.Box(new CANNON.Vec3(fenceThickness/2, fenceHeight/2, trackWidth/2));
  const boxBodyR = new CANNON.Body({mass: 0, shape: boxShapeR});
  boxBodyR.position.set(Math.cos(rad)*(trackRadius + trackWidth + fenceThickness/2), fenceHeight/2, Math.sin(rad)*(trackRadius + trackWidth + fenceThickness/2));
  boxBodyR.quaternion.copy(new CANNON.Quaternion().setFromEuler(0, -rad, 0));
  world.addBody(boxBodyR);
}

// --- Car physics & visuals ---
// Rounded box geometry helper
function createRoundedBoxGeometry(width, height, depth, radius, segments=3){
  const shape = new THREE.Shape();
  const eps = 0.00001;
  const radius0 = radius - eps;
  shape.absarc( eps, eps, eps, -Math.PI/2, -Math.PI, true );
  shape.absarc( eps, height -  radius * 2, eps, Math.PI, Math.PI/2, true );
  shape.absarc( width -  radius * 2, height -  radius * 2, eps, Math.PI/2, 0, true );
  shape.absarc( width -  radius * 2, eps, eps, 0, -Math.PI/2, true );
  const geometry = new THREE.ExtrudeGeometry(shape, {
    depth: depth - radius * 2,
    bevelEnabled: true,
    bevelSegments: segments,
    steps: 1,
    bevelSize: radius0,
    bevelThickness: radius,
    curveSegments: segments
  });
  geometry.center();
  return geometry;
}

const chassisWidth = 3;
const chassisHeight = 1;
const chassisDepth = 6;
const chassisRadius = 0.3;

const chassisShape = new CANNON.Box(new CANNON.Vec3(chassisWidth/2, chassisHeight/2, chassisDepth/2));
const chassisBody = new CANNON.Body({mass: 200});
chassisBody.addShape(chassisShape);
chassisBody.position.set(trackRadius + 5, 2, 0);
chassisBody.angularDamping = 0.5;
world.addBody(chassisBody);

const chassisMaterial = new THREE.MeshStandardMaterial({color: 0xff0000, metalness: 0.7, roughness: 0.4});
const chassisGeometry = createRoundedBoxGeometry(chassisWidth, chassisHeight, chassisDepth, chassisRadius, 5);
const chassisMesh = new THREE.Mesh(chassisGeometry, chassisMaterial);
scene.add(chassisMesh);

// Vehicle setup
const vehicle = new CANNON.RaycastVehicle({
  chassisBody: chassisBody,
  indexRightAxis: 0,
  indexUpAxis: 1,
  indexForwardAxis: 2,
});

const wheelOptions = {
  radius: 0.5,
  directionLocal: new CANNON.Vec3(0, -1, 0),
  suspensionStiffness: 30,
  suspensionRestLength: 0.3,
  frictionSlip: 5,
  dampingRelaxation: 2.3,
  dampingCompression: 4.4,
  maxSuspensionForce: 100000,
  rollInfluence: 0.01,
  axleLocal: new CANNON.Vec3(-1, 0, 0),
  maxSuspensionTravel: 0.3,
  useCustomSlidingRotationalSpeed: true,
  customSlidingRotationalSpeed: -30,
};

vehicle.addWheel({
  ...wheelOptions,
  chassisConnectionPointLocal: new CANNON.Vec3(-1.2, 0, 2.4),
  isFrontWheel: true,
});
vehicle.addWheel({
  ...wheelOptions,
  chassisConnectionPointLocal: new CANNON.Vec3(1.2, 0, 2.4),
  isFrontWheel: true,
});
vehicle.addWheel({
  ...wheelOptions,
  chassisConnectionPointLocal: new CANNON.Vec3(-1.2, 0, -2.4),
  isFrontWheel: false,
});
vehicle.addWheel({
  ...wheelOptions,
  chassisConnectionPointLocal: new CANNON.Vec3(1.2, 0, -2.4),
  isFrontWheel: false,
});

vehicle.addToWorld(world);

const wheelMeshes = [];
vehicle.wheelInfos.forEach(() => {
  const wheelGeo = new THREE.CylinderGeometry(0.5, 0.5, 0.4, 32);
  const wheelMat = new THREE.MeshStandardMaterial({color: 0x111111, metalness: 0.7, roughness: 0.5});
  const wheelMesh = new THREE.Mesh(wheelGeo, wheelMat);
  wheelMesh.rotation.z = Math.PI / 2; // 바퀴가 옆으로 누워있도록
  scene.add(wheelMesh);
  wheelMeshes.push(wheelMesh);
});

// Lighting
const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
scene.add(ambientLight);
const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
directionalLight.position.set(10, 30, 20);
directionalLight.castShadow = true;
scene.add(directionalLight);

// Driving variables
let engineForce = 0;
const maxEngineForce = 2500; // 속도 느리게 조정
const maxBrakeForce = 400;
let brakeForce = 0;

let steeringValue = 0;
const maxSteerVal = Math.PI / 8; // 약 22.5도

// Gear states
let gearState = 'P'; // P, R, N, D
const gears = ['P', 'R', 'N', 'D'];
let gearIndex = 0;

function updateGearDisplay() {
  gearDisplay.textContent = `기어: ${gearState}`;
}

// Input state
const input = {
  left: false,
  right: false,
  accel: false,
  brake: false,
};

// Input bindings
function bindBtnEvents(button, prop) {
  button.addEventListener('mousedown', () => { input[prop] = true; });
  button.addEventListener('mouseup', () => { input[prop] = false; });
  button.addEventListener('touchstart', e => { e.preventDefault(); input[prop] = true; });
  button.addEventListener('touchend', e => { e.preventDefault(); input[prop] = false; });
}
bindBtnEvents(btnLeft, 'left');
bindBtnEvents(btnRight, 'right');
bindBtnEvents(btnAccel, 'accel');
bindBtnEvents(btnBrake, 'brake');

btnGear.addEventListener('click', () => {
  gearIndex = (gearIndex + 1) % gears.length;
  gearState = gears[gearIndex];
  updateGearDisplay();

  if (gearState === 'P') {
    applyBrake(1e5);
    engineForce = 0;
  } else if (gearState === 'N') {
    engineForce = 0;
    brakeForce = 0;
  }
});
updateGearDisplay();

function applyBrake(force) {
  for(let i=0; i<4; i++) {
    vehicle.setBrake(force, i);
  }
}

function updateVehiclePhysics(delta) {
  brakeForce = 0;
  engineForce = 0;

  if (gearState === 'P') {
    applyBrake(1e5);
    return;
  } else if (gearState === 'N') {
    applyBrake(0);
  } else if (gearState === 'D') {
    if (input.accel) engineForce = maxEngineForce;
    brakeForce = input.brake ? maxBrakeForce : 0;
  } else if (gearState === 'R') {
    if (input.accel) engineForce = -maxEngineForce * 0.6;
    brakeForce = input.brake ? maxBrakeForce : 0;
  }

  steeringValue = 0;
  if (input.left) steeringValue += maxSteerVal;
  if (input.right) steeringValue -= maxSteerVal;

  for (let i = 0; i < vehicle.wheelInfos.length; i++) {
    if (vehicle.wheelInfos[i].isFrontWheel) {
      vehicle.setSteeringValue(steeringValue, i);
    }
    vehicle.applyEngineForce(engineForce, i);
    vehicle.setBrake(brakeForce, i);
  }
}

function updateVisuals() {
  chassisMesh.position.copy(chassisBody.position);
  chassisMesh.quaternion.copy(chassisBody.quaternion);

  for (let i = 0; i < vehicle.wheelInfos.length; i++) {
    vehicle.updateWheelTransform(i);
    const t = vehicle.wheelInfos[i].worldTransform;
    wheelMeshes[i].position.copy(t.position);
    wheelMeshes[i].quaternion.copy(t.quaternion);
    wheelMeshes[i].rotateX(Math.PI / 2);
  }
}

function updateCamera() {
  const relativeCameraOffset = new THREE.Vector3(0, 5, -12);
  const cameraOffset = relativeCameraOffset.applyQuaternion(chassisMesh.quaternion).add(chassisMesh.position);
  camera.position.lerp(cameraOffset, 0.1);

  const carForward = new THREE.Vector3(0, 0, 1).applyQuaternion(chassisMesh.quaternion);
  const lookAtPos = chassisMesh.position.clone().add(carForward.multiplyScalar(15));
  camera.lookAt(lookAtPos);
}

function updateHUD() {
  const velocity = chassisBody.velocity.length();
  const kmh = Math.round(velocity * 3.6);
  hud.textContent = `속도: ${kmh} km/h`;
}

const clock = new THREE.Clock();

function animate() {
  requestAnimationFrame(animate);

  const delta = clock.getDelta();
  updateVehiclePhysics(delta);

  world.step(1/60, delta, 3);
  updateVisuals();
  updateCamera();
  updateHUD();

  renderer.render(scene, camera);
}
animate();
</script>
</body>
</html>
