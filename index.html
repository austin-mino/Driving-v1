<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>완벽한 3D 자동차 게임</title>
  <style>
    /* ---------- Global Styles & UI ---------- */
    body{
      margin:0;overflow:hidden;background:#121212;
      font-family:'Segoe UI',Tahoma,Verdana,sans-serif;color:#fff
    }
    #rotateWarning{
      position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);
      background:rgba(0,0,0,.85);padding:25px 40px;border-radius:15px;
      font-size:1.3rem;font-weight:bold;z-index:1000;display:none
    }
    #hud,#gearDisplay,#lapTime{
      position:fixed;background:rgba(0,0,0,.7);padding:12px 18px;border-radius:10px;
      font-weight:700;font-size:18px;user-select:none;z-index:100;font-family:monospace
    }
    #hud{top:20px;left:20px}
    #gearDisplay{top:20px;right:20px}
    #lapTime{top:70px;right:20px}
    #gearControls{
      position:fixed;top:120px;right:20px;display:flex;flex-direction:column;gap:10px;z-index:100
    }
    #controlsLeft,#driveControls{
      position:fixed;bottom:20px;display:flex;gap:15px;z-index:100;user-select:none
    }
    #controlsLeft{left:20px}
    #driveControls{right:20px}
    button.controlBtn{
      padding:14px 20px;border-radius:12px;border:none;background:#0078d7;color:#fff;
      font-weight:700;font-size:16px;cursor:pointer;touch-action:manipulation
    }
    button.controlBtn:active{background:#005a9e}
    @media(max-width:600px){
      button.controlBtn{padding:18px 22px;font-size:20px}
    }
  </style>
</head>
<body>
  <!-- ---------- UI Elements ---------- -->
  <div id="rotateWarning">가로 모드로 전환해주세요</div>
  <div id="hud">속도: 0 km/h</div>
  <div id="gearDisplay">기어: P</div>
  <div id="lapTime">랩: 0 / 0:00.000</div>

  <div id="controlsLeft">
    <button id="btnLeft"  class="controlBtn">◀ 좌</button>
    <button id="btnRight" class="controlBtn">우 ▶</button>
  </div>

  <div id="driveControls">
    <button id="btnAccel" class="controlBtn">엑셀</button>
    <button id="btnBrake" class="controlBtn">브레이크</button>
  </div>

  <div id="gearControls">
    <button id="gearP" class="controlBtn">P</button>
    <button id="gearR" class="controlBtn">R</button>
    <button id="gearN" class="controlBtn">N</button>
    <button id="gearD" class="controlBtn">D</button>
  </div>

<script type="module">
/* --------------------------------------------------
   IMPORTS
--------------------------------------------------*/
import * as THREE  from 'https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js';
import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js';

/* --------------------------------------------------
   UTILS & CONSTANTS
--------------------------------------------------*/
const DEG2RAD = Math.PI / 180;
const trackRadius = 50;
const trackWidth  = 10;
const trackSegs   = 96;

/* --------------------------------------------------
   UI ELEMENT REFERENCES
--------------------------------------------------*/
const rotateWarning = document.getElementById('rotateWarning');
const hud           = document.getElementById('hud');
const gearDisp      = document.getElementById('gearDisplay');
const lapDisp       = document.getElementById('lapTime');

/* --------------------------------------------------
   ORIENTATION CHECK
--------------------------------------------------*/
function checkOrientation(){
  rotateWarning.style.display = (innerHeight > innerWidth) ? 'block' : 'none';
}
addEventListener('resize',checkOrientation);
addEventListener('orientationchange',checkOrientation);
checkOrientation();

/* --------------------------------------------------
   THREE: SCENE / CAMERA / RENDERER
--------------------------------------------------*/
const scene   = new THREE.Scene();
scene.background = new THREE.Color(0x202020);

const camera  = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 5000);
camera.position.set(0,5,12);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth,innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type    = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

addEventListener('resize',()=>{
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});

/* --------------------------------------------------
   CANNON WORLD
--------------------------------------------------*/
const world = new CANNON.World({gravity:new CANNON.Vec3(0,-9.82,0)});
world.broadphase = new CANNON.SAPBroadphase(world);
world.defaultContactMaterial.friction = 0.6;

/* --------------------------------------------------
   GROUND & TRACK
--------------------------------------------------*/
// Physics ground plane
const groundBody = new CANNON.Body({mass:0,shape:new CANNON.Plane()});
groundBody.quaternion.setFromEuler(-Math.PI/2,0,0);
world.addBody(groundBody);

// Visual ground
const groundMesh = new THREE.Mesh(
  new THREE.PlaneGeometry(300,300),
  new THREE.MeshStandardMaterial({color:0x222222})
);
groundMesh.rotation.x = -Math.PI/2;
groundMesh.receiveShadow = true;
scene.add(groundMesh);

// Track visual
const trackMesh = new THREE.Mesh(
  new THREE.RingGeometry(trackRadius-trackWidth/2, trackRadius+trackWidth/2, trackSegs),
  new THREE.MeshStandardMaterial({color:0x333333,side:THREE.DoubleSide})
);
trackMesh.rotation.x = -Math.PI/2;
trackMesh.receiveShadow = true;
scene.add(trackMesh);

// Track barriers (both inner & outer)
const barrierH = 3, barrierT = 1;
function addBarrier(x,z,a){
  const shape = new CANNON.Box(new CANNON.Vec3(barrierT/2, barrierH/2, trackWidth/2));
  const body  = new CANNON.Body({mass:0,shape});
  body.position.set(x, barrierH/2, z);
  body.quaternion.setFromEuler(0,-a,0);
  world.addBody(body);

  const mesh  = new THREE.Mesh(
    new THREE.BoxGeometry(barrierT, barrierH, trackWidth),
    new THREE.MeshStandardMaterial({color:0x661111})
  );
  mesh.position.copy(body.position);
  mesh.quaternion.copy(body.quaternion);
  mesh.castShadow = true;
  scene.add(mesh);
}
for(let i=0;i<trackSegs;i++){
  const a=i/trackSegs*2*Math.PI;
  addBarrier(Math.cos(a)*(trackRadius+trackWidth/2),
             Math.sin(a)*(trackRadius+trackWidth/2),a);
  addBarrier(Math.cos(a)*(trackRadius-trackWidth/2),
             Math.sin(a)*(trackRadius-trackWidth/2),a+Math.PI);
}

/* --------------------------------------------------
   LIGHTING
--------------------------------------------------*/
scene.add(new THREE.AmbientLight(0xffffff,0.4));

const dirLight = new THREE.DirectionalLight(0xffffff,0.9);
dirLight.position.set(30,50,30);
dirLight.castShadow = true;
dirLight.shadow.mapSize.set(2048,2048);
scene.add(dirLight);

/* --------------------------------------------------
   CAR FACTORY
--------------------------------------------------*/
function buildCarMesh(col){
  const g = new THREE.Group();
  const mat = new THREE.MeshStandardMaterial({color:col,metalness:0.6,roughness:0.4});
  const body = new THREE.Mesh(new THREE.BoxGeometry(3,1.2,6),mat);
  body.position.y=0.6; body.castShadow = body.receiveShadow = true;
  g.add(body);
  return g;
}

/* --------------------------------------------------
   PLAYER VEHICLE (RaycastVehicle)
--------------------------------------------------*/
const carMesh = buildCarMesh(0xff4444);
scene.add(carMesh);

const chassisBody = new CANNON.Body({mass:150});
chassisBody.addShape(new CANNON.Box(new CANNON.Vec3(1.5,0.5,3)));
chassisBody.position.set(0,2,trackRadius);
chassisBody.angularDamping = 0.5;
world.addBody(chassisBody);

const vehicle = new CANNON.RaycastVehicle({
  chassisBody,
  indexRightAxis:0,
  indexUpAxis:1,
  indexForwardAxis:2
});

const wheelOptBase = {
  radius:0.55, directionLocal:new CANNON.Vec3(0,-1,0),
  suspensionStiffness:50, suspensionRestLength:0.35,
  frictionSlip:5, dampingRelaxation:2.8, dampingCompression:4.6,
  maxSuspensionForce:100000, rollInfluence:0.01,
  axleLocal:new CANNON.Vec3(-1,0,0),
  maxSuspensionTravel:0.3,
  useCustomSlidingRotationalSpeed:true,
  customSlidingRotationalSpeed:-30
};
[
  {p:new CANNON.Vec3(-1.2,0, 2.4),front:true},
  {p:new CANNON.Vec3( 1.2,0, 2.4),front:true},
  {p:new CANNON.Vec3(-1.2,0,-2.4),front:false},
  {p:new CANNON.Vec3( 1.2,0,-2.4),front:false}
].forEach(w=>{
  vehicle.addWheel({...wheelOptBase, chassisConnectionPointLocal:w.p, isFrontWheel:w.front});
});
vehicle.addToWorld(world);

// Wheel visuals
const wheelMeshes=[];
vehicle.wheelInfos.forEach(w=>{
  const m=new THREE.Mesh(
    new THREE.CylinderGeometry(w.radius,w.radius,0.4,32),
    new THREE.MeshStandardMaterial({color:0x111111,metalness:0.7,roughness:0.5})
  );
  m.rotation.z=Math.PI/2; m.castShadow=true;
  scene.add(m); wheelMeshes.push(m);
});

/* --------------------------------------------------
   AI CAR (simple circular motion)
--------------------------------------------------*/
const aiMesh = buildCarMesh(0x3399ff); scene.add(aiMesh);
const aiBody = new CANNON.Body({mass:150});
aiBody.addShape(new CANNON.Box(new CANNON.Vec3(1.5,0.5,3)));
aiBody.position.set(0,2,trackRadius-3);
aiBody.angularDamping = 0.5;
world.addBody(aiBody);
const aiSpeed = 20; // km/h

/* --------------------------------------------------
   INPUT HANDLING
--------------------------------------------------*/
const input={left:false,right:false,accel:false,brake:false};
function bind(btn,id){
  btn.addEventListener('mousedown',()=>input[id]=true);
  btn.addEventListener('mouseup',  ()=>input[id]=false);
  btn.addEventListener('touchstart',e=>{e.preventDefault();input[id]=true});
  btn.addEventListener('touchend',  e=>{e.preventDefault();input[id]=false});
}
bind(document.getElementById('btnLeft'),'left');
bind(document.getElementById('btnRight'),'right');
bind(document.getElementById('btnAccel'),'accel');
bind(document.getElementById('btnBrake'),'brake');

/* --------------------------------------------------
   DRIVING & GEAR
--------------------------------------------------*/
let gear='P'; updateGear();
function updateGear(){ gearDisp.textContent=`기어: ${gear}`; playShift(); }
['P','R','N','D'].forEach(g=>{
  document.getElementById('gear'+g).onclick=()=>{
    gear=g; updateGear();
    if(g==='P') applyBrake(1e5);
  };
});
function applyBrake(f){for(let i=0;i<4;i++) vehicle.setBrake(f,i);}

const maxEngine=1800, maxBrake=400, maxSteer=Math.PI/8;
let steering=0;

/* --------------------------------------------------
   SOUND SETUP
--------------------------------------------------*/
const AudioCtx = window.AudioContext||window.webkitAudioContext;
const ctx = new AudioCtx();
function osc(freq,type='sawtooth'){
  const o=ctx.createOscillator();o.type=type;o.frequency.value=freq;
  const g=ctx.createGain();g.gain.value=0;o.connect(g).connect(ctx.destination);o.start();
  return{osc:o,gain:g};
}
const sndEngine = osc(0,'sawtooth');
const sndTire   = osc(0,'triangle');
const sndShift  = osc(600,'square');
function playShift(){
  sndShift.gain.gain.setValueAtTime(0.2,ctx.currentTime);
  sndShift.gain.gain.exponentialRampToValueAtTime(0.001,ctx.currentTime+0.3);
}
function updSound(v,eng,brk){
  if(ctx.state==='suspended') ctx.resume();
  sndEngine.gain.gain.linearRampToValueAtTime(eng?0.15:0.001,ctx.currentTime+0.05);
  sndEngine.osc.frequency.linearRampToValueAtTime(eng?(100+v*7):50,ctx.currentTime+0.05);
  sndTire.gain.gain.linearRampToValueAtTime(brk?0.1:0,ctx.currentTime+0.05);
}

/* --------------------------------------------------
   LAP TIMER
--------------------------------------------------*/
let lapCnt=0,start=null;
function updLap(pos){
  const a=Math.atan2(pos.z,pos.x);
  if(pos.z<0&&pos.x>0){if(!start){start=performance.now();lapCnt++;}}
  if(start){const t=performance.now()-start;lapDisp.textContent=`랩: ${lapCnt} / ${(t/1000).toFixed(3)}`;}
}

/* --------------------------------------------------
   AI UPDATE
--------------------------------------------------*/
function updAI(dt){
  const ang=performance.now()/1000*(aiSpeed/3.6)/trackRadius;
  aiBody.position.set(Math.cos(ang)*trackRadius,2,Math.sin(ang)*trackRadius);
  aiBody.quaternion.setFromEuler(0,-ang+Math.PI/2,0);
  aiMesh.position.copy(aiBody.position);
  aiMesh.quaternion.copy(aiBody.quaternion);
}

/* --------------------------------------------------
   ANIMATE
--------------------------------------------------*/
const clock=new THREE.Clock();
function animate(){
  const dt=clock.getDelta();

  // input → forces
  let engine=0, brake=0;
  if(gear!=='P'){
    if(input.accel){
      engine = (gear==='R'?-0.6:1)*maxEngine;
    }
    if(input.brake) brake = maxBrake;
  }
  steering= input.left ? maxSteer : input.right ? -maxSteer : 0;

  vehicle.wheelInfos.forEach((w,i)=>{
    if(w.isFrontWheel) vehicle.setSteeringValue(steering,i);
    vehicle.applyEngineForce(engine,i);
    vehicle.setBrake(brake,i);
  });

  world.step(1/60,dt,3);

  // visual sync
  carMesh.position.copy(chassisBody.position);
  carMesh.quaternion.copy(chassisBody.quaternion);
  vehicle.wheelInfos.forEach((w,i)=>{
    vehicle.updateWheelTransform(i);
    wheelMeshes[i].position.copy(w.worldTransform.position);
    wheelMeshes[i].quaternion.copy(w.worldTransform.quaternion);
    wheelMeshes[i].rotateX(Math.PI/2);
  });

  // camera
  const cOff=new THREE.Vector3(0,5,12).applyQuaternion(carMesh.quaternion);
  camera.position.lerp(chassisBody.position.clone().add(cOff),0.1);
  camera.lookAt(chassisBody.position);

  // HUD & sound
  const speed=chassisBody.velocity.length()*3.6;
  hud.textContent=`속도: ${speed.toFixed(0)} km/h`;
  updSound(speed,input.accel && gear==='D',Boolean(brake));
  updLap(chassisBody.position);

  // AI
  updAI(dt);

  renderer.render(scene,camera);
  requestAnimationFrame(animate);
}
animate();
</script>
</body>
</html>
